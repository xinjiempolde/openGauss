/*
 * *** Do not change this file by hand. It is automatically
 * *** generated from the DocBook documentation.
 *
 * generated by
 *     /usr/bin/perl create_help.pl ../../../doc/src/sgml/ref sql_help
 *
 */

#include "sql_help.h"

void
sql_help_ABORT(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "ABORT [ WORK | TRANSACTION ] ;");
}

void
sql_help_ALTER_APP_WORKLOAD_GROUP(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "ALTER APP WORKLOAD GROUP MAPPING app_name WITH ([ WORKLOAD_GPNAME  = workload_gpname, ])");
}

void
sql_help_ALTER_APP_WORKLOAD_GROUP_MAPPING(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "ALTER APP WORKLOAD GROUP MAPPING app_name\n"
					  "    WITH ( WORKLOAD_GPNAME = wg_name );");
}

void
sql_help_ALTER_AUDIT_POLICY(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "ALTER AUDIT POLICY [ IF EXISTS ] policy_name { ADD | REMOVE } { [ privilege_audit_clause ] [ access_audit_clause ] }; \n"
					  "ALTER AUDIT POLICY [ IF EXISTS ] policy_name MODIFY ( filter_group_clause ); \n"
					  "ALTER AUDIT POLICY [ IF EXISTS ] policy_name DROP FILTER; \n"
					  "ALTER AUDIT POLICY [ IF EXISTS ] policy_name COMMENTS policy_comments; \n"
					  "ALTER AUDIT POLICY [ IF EXISTS ] policy_name { ENABLE | DISABLE }; \n"
					  "\n"
					  "where privilege_audit_clause can be:\n"
					  "PRIVILEGES { DDL | ALL }\n"
					  "\n"
					  "where access_audit_clause can be:\n"
					  "ACCESS { DML | ALL }\n"
					  "\n"
					  "where filter_group_clause can be:\n"
					  "FILTER ON { ( FILTER_TYPE ( filter_value [, ... ] ) ) [, ... ] }\n"
					  "\n"
					  "where DDL can be:\n"
					  "{ ( ALTER | ANALYZE | COMMENT | CREATE | DROP | GRANT | REVOKE | SET | SHOW | LOGIN_ACCESS | LOGIN_FAILURE | LOGOUT | LOGIN ) }\n"
					  "\n"
					  "where DML can be: \n"
					  "{ ( COPY | DEALLOCATE | DELETE_P | EXECUTE | REINDEX | INSERT | REPARE | SELECT | TRUNCATE | UPDATE ) }");
}

void
sql_help_ALTER_DATA_SOURCE(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "ALTER DATA SOURCE src_name\n"
					  "    [TYPE 'type_str']\n"
					  "    [VERSION {'version_str' | NULL}] \n"
					  "    [OPTIONS ( { [ADD | SET | DROP] optname ['optvalue'] } [, ...] )];\n"
					  "ALTER DATA SOURCE src_name RENAME TO src_new_name;\n"
					  "ALTER DATA SOURCE src_name OWNER TO new_owner;\n"
					  "\n"
					  "Valid optname are:\n"
					  "    DSN, USERNAME, PASSWORD, ENCODING");
}

void
sql_help_ALTER_DATABASE(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "ALTER DATABASE database_name\n"
					  "    [ [ WITH ] CONNECTION LIMIT connlimit ];\n"
					  "ALTER DATABASE database_name\n"
					  "    RENAME TO new_name;\n"
					  "ALTER DATABASE database_name\n"
					  "    OWNER TO new_owner;\n"
					  "ALTER DATABASE database_name\n"
					  "    SET TABLESPACE new_tablespace;\n"
					  "ALTER DATABASE database_name\n"
					  "    SET configuration_parameter { { TO | = } { value | DEFAULT }  | FROM CURRENT };\n"
					  "ALTER DATABASE database_name\n"
					  "    RESET { configuration_parameter | ALL };\n"
					  "ALTER DATABASE database_name\n"
					  "    [ WITH ] { ENABLE | DISABLE } PRIVATE OBJECT;");
}

void
sql_help_ALTER_DEFAULT_PRIVILEGES(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "ALTER DEFAULT PRIVILEGES\n"
					  "    [ FOR { ROLE | USER } target_role [, ...] ]\n"
					  "    [ IN SCHEMA schema_name [, ...] ]\n"
					  "    abbreviated_grant_or_revoke;\n"
					  "\n"
					  "where abbreviated_grant_or_revoke can be:\n"
					  "grant_on_tables_clause\n"
					  "  | grant_on_functions_clause\n"
					  "  | grant_on_types_clause\n"
					  "  | revoke_on_tables_clause\n"
					  "  | revoke_on_functions_clause\n"
					  "  | revoke_on_types_clause\n"
					  "where grant_on_tables_clause can be:\n"
					  "GRANT { { SELECT | INSERT | UPDATE | DELETE | TRUNCATE | REFERENCES |\n"
					  "    ALTER | DROP | COMMENT | INDEX | VACUUM } [, ...] | ALL [ PRIVILEGES ] }\n"
					  "    ON TABLES\n"
					  "    TO { [ GROUP ] role_name | PUBLIC } [, ...]\n"
					  "    [ WITH GRANT OPTION ]\n"
					  "where grant_on_functions_clause can be:\n"
					  "GRANT { { EXECUTE | ALTER | DROP | COMMENT } [, ...] | ALL [ PRIVILEGES ] }\n"
					  "    ON FUNCTIONS\n"
					  "    TO { [ GROUP ] role_name | PUBLIC } [, ...]\n"
					  "    [ WITH GRANT OPTION ]\n"
					  "where grant_on_types_clause can be:\n"
					  "GRANT { { USAGE | ALTER | DROP | COMMENT } [, ...] | ALL [ PRIVILEGES ] }\n"
					  "    ON TYPES\n"
					  "    TO { [ GROUP ] role_name | PUBLIC } [, ...]\n"
					  "    [ WITH GRANT OPTION ]\n"
					  "where revoke_on_tables_clause can be:\n"
					  "REVOKE [ GRANT OPTION FOR ]\n"
					  "    { { SELECT | INSERT | UPDATE | DELETE | TRUNCATE | REFERENCES |\n"
					  "    ALTER | DROP | COMMENT | INDEX | VACUUM } [, ...] | ALL [ PRIVILEGES ] }\n"
					  "    ON TABLES\n"
					  "    FROM { [ GROUP ] role_name | PUBLIC } [, ...]\n"
					  "    [ CASCADE | RESTRICT | CASCADE CONSTRAINTS ]\n"
					  "where revoke_on_functions_clause can be:\n"
					  "REVOKE [ GRANT OPTION FOR ]\n"
					  "    { { EXECUTE | ALTER | DROP | COMMENT } [, ...] | ALL [ PRIVILEGES ] }\n"
					  "    ON FUNCTIONS\n"
					  "    FROM { [ GROUP ] role_name | PUBLIC } [, ...]\n"
					  "    [ CASCADE | RESTRICT | CASCADE CONSTRAINTS ]\n"
					  "where revoke_on_types_clause can be:\n"
					  "REVOKE [ GRANT OPTION FOR ]\n"
					  "    { { USAGE | ALTER | DROP | COMMENT } [, ...] | ALL [ PRIVILEGES ] }\n"
					  "    ON TYPES\n"
					  "    FROM { [ GROUP ] role_name | PUBLIC } [, ...]\n"
					  "    [ CASCADE | RESTRICT | CASCADE CONSTRAINTS ]");
}

void
sql_help_ALTER_DIRECTORY(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "ALTER DIRECTORY directory_name\n"
					  "    OWNER TO new_owner;");
}

void
sql_help_ALTER_EXTENSION(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "ALTER EXTENSION %s UPDATE [ TO %s ];\n"
					  "ALTER EXTENSION %s SET SCHEMA %s;\n"
					  "ALTER EXTENSION %s ADD %s;\n"
					  "ALTER EXTENSION %s DROP %s;\n"
					  "\n"
					  "%s\n"
					  "\n"
					  "  FOREIGN TABLE %s |\n"
					  "  FUNCTION %s ( [ [ %s ] [ %s ] %s [, ...] ] ) |\n"
					  "  [ PROCEDURAL ] LANGUAGE %s |\n"
					  "  SCHEMA %s |\n"
					  "  SERVER %s |\n"
					  "  TABLE %s |\n"
					  "  TEXT SEARCH CONFIGURATION %s |\n"
					  "  TYPE %s |\n"
					  "  VIEW %s",
					  _("name"),
					  _("new_version"),
					  _("name"),
					  _("new_schema"),
					  _("name"),
					  _("member_object"),
					  _("name"),
					  _("member_object"),
					  _("where member_object is:"),
					  _("object_name"),
					  _("function_name"),
					  _("argmode"),
					  _("argname"),
					  _("argtype"),
					  _("object_name"),
					  _("object_name"),
					  _("object_name"),
					  _("object_name"),
					  _("object_name"),
					  _("object_name"),
					  _("object_name"));
}

void
sql_help_ALTER_FOREIGN_TABLE(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "1. GDS:\n"
					  "ALTER FOREIGN TABLE [ IF EXISTS ]  table_name\n"
					  "    OPTIONS ( {[ ADD | SET | DROP ] option ['value']} [, ... ]);\n"
					  "ALTER FOREIGN TABLE [ IF EXISTS ] tablename\n"
					  "    OWNER TO new_owner;\n"
					  "\n"
					  "2. HDFS:\n"
					  "ALTER FOREIGN TABLE [ IF EXISTS ]  table_name\n"
					  "    OPTIONS ( {[ ADD | SET | DROP ] option ['value']} [, ... ]);\n"
					  "ALTER FOREIGN TABLE [ IF EXISTS ] tablename\n"
					  "    OWNER TO new_owner;\n"
					  "ALTER FOREIGN TABLE [ IF EXISTS ] table_name\n"
					  "    MODIFY ( { column_name data_type | column_name [ CONSTRAINT constraint_name ] NOT NULL [ ENABLE ] | column_name [ CONSTRAINT constraint_name ] NULL } [, ...] );\n"
					  "ALTER FOREIGN TABLE [ IF EXISTS ] tablename\n"
					  "    ADD [CONSTRAINT constraint_name]\n"
					  "	{PRIMARY KEY | UNIQUE} (column_name)\n"
					  "	[NOT ENFORCED [ENABLE QUERY OPTIMIZATION | DISABLE QUERY OPTIMIZATION] | ENFORCED];\n"
					  "ALTER FOREIGN TABLE [ IF EXISTS ] tablename\n"
					  "    DROP CONSTRAINT constraint_name ;\n"
					  "ALTER FOREIGN TABLE [ IF EXISTS ] tablename\n"
					  "    action [, ... ];\n"
					  "\n"
					  "where action can be:\n"
					  "ALTER [ COLUMN ] column_name [ SET DATA ] TYPE data_type\n"
					  "|   ALTER [ COLUMN ] column_name { SET | DROP } NOT NULL\n"
					  "|   ALTER [ COLUMN ] column_name SET STATISTICS  integer\n"
					  "|   ALTER [ COLUMN ] column_name OPTIONS ( {[ ADD | SET | DROP ] option ['value'] } [, ... ])\n"
					  "|   MODIFY column_name data_type\n"
					  "|   MODIFY column_name [ CONSTRAINT constraint_name ] NOT NULL [ ENABLE ]\n"
					  "|   MODIFY column_name [ CONSTRAINT constraint_name ] NULL\n"
					  "\n"
					  "3. OBS:\n"
					  "ALTER FOREIGN TABLE [ IF EXISTS ]  table_name\n"
					  "    OPTIONS ( {[ ADD | SET | DROP ] option ['value']} [, ... ]);\n"
					  "ALTER FOREIGN TABLE [ IF EXISTS ] tablename\n"
					  "    OWNER TO new_owner;\n"
					  "ALTER FOREIGN TABLE [ IF EXISTS ] table_name\n"
					  "    MODIFY ( { column_name data_type | column_name [ CONSTRAINT constraint_name ] NOT NULL [ ENABLE ] | column_name [ CONSTRAINT constraint_name ] NULL } [, ...] );\n"
					  "ALTER FOREIGN TABLE [ IF EXISTS ] tablename\n"
					  "    ADD [CONSTRAINT constraint_name]\n"
					  "	{PRIMARY KEY | UNIQUE} (column_name)\n"
					  "	[NOT ENFORCED [ENABLE QUERY OPTIMIZATION | DISABLE QUERY OPTIMIZATION] | ENFORCED];\n"
					  "ALTER FOREIGN TABLE [ IF EXISTS ] tablename\n"
					  "    DROP CONSTRAINT constraint_name ;\n"
					  "ALTER FOREIGN TABLE [ IF EXISTS ] tablename\n"
					  "    action [, ... ];\n"
					  "\n"
					  "where action can be:\n"
					  "ALTER [ COLUMN ] column_name [ SET DATA ] TYPE data_type\n"
					  "|   ALTER [ COLUMN ] column_name { SET | DROP } NOT NULL\n"
					  "|   ALTER [ COLUMN ] column_name SET STATISTICS  integer\n"
					  "|   ALTER [ COLUMN ] column_name OPTIONS ( {[ ADD | SET | DROP ] option ['value'] } [, ... ])\n"
					  "|   MODIFY column_name data_type\n"
					  "|   MODIFY column_name [ CONSTRAINT constraint_name ] NOT NULL [ ENABLE ]\n"
					  "|   MODIFY column_name [ CONSTRAINT constraint_name ] NULL\n"
					  "\n"
					  "4. GC:\n"
					  "ALTER FOREIGN TABLE [ IF EXISTS ]  tablename\n"
					  "    OPTIONS ( {[ SET ] option ['value']} [, ... ]);\n"
					  "ALTER FOREIGN TABLE [ IF EXISTS ] tablename\n"
					  "    OWNER TO new_owner;\n"
					  "ALTER FOREIGN TABLE [ IF EXISTS ] table_name\n"
					  "    MODIFY ( { column_name data_type [, ...] );\n"
					  "ALTER FOREIGN TABLE [ IF EXISTS ] tablename\n"
					  "    action [, ... ];\n"
					  "   \n"
					  "where action can be:\n"
					  "ALTER [ COLUMN ] column_name [ SET DATA ] TYPE data_type\n"
					  "|   MODIFY column_name data_type");
}

void
sql_help_ALTER_FOREIGN_TABLE_FOR_HDFS(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "ALTER FOREIGN TABLE [ IF EXISTS ] tablename\n"
					  "    OWNER TO new_owner;\n"
					  "ALTER FOREIGN TABLE [ IF EXISTS ] tablename\n"
					  "    action [, ... ];\n"
					  "ALTER FOREIGN TABLE [ IF EXISTS ] tablename\n"
					  "    ADD [CONSTRAINT constraint_name]\n"
					  "{PRIMARY KEY | UNIQUE} (column_name)\n"
					  "[NOT ENFORCED [ENABLE QUERY OPTIMIZATION | DISABLE QUERY OPTIMIZATION] | ENFORCED];\n"
					  "ALTER FOREIGN TABLE [ IF EXISTS ] tablename\n"
					  "    DROP CONSTRAINT constraint_name ;\n"
					  "\n"
					  "where action can be:\n"
					  "ALTER [ COLUMN ] column_name [ SET DATA ] TYPE data_type\n"
					  "|    ALTER [ COLUMN ] column_name { SET | DROP } NOT NULL\n"
					  "|    ALTER [ COLUMN ] column_name SET STATISTICS [PERCENT] integer");
}

void
sql_help_ALTER_FUNCTION(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "ALTER FUNCTION function_name ( [ {[ argmode ] [ argname ] argtype} [, ...] ] )\n"
					  "    action [ ... ] [ RESTRICT ];\n"
					  "ALTER FUNCTION funname ( [ {[ argmode ] [ argname ] argtype} [, ...] ] )\n"
					  "    RENAME TO new_name;\n"
					  "ALTER FUNCTION funname ( [ {[ argmode ] [ argname ] argtype} [, ...] ] )\n"
					  "    OWNER TO new_owner;\n"
					  "ALTER FUNCTION funname ( [ {[ argmode ] [ argname ] argtype} [, ...] ] )\n"
					  "    SET SCHEMA new_schema;\n"
					  "\n"
					  "where action can be:\n"
					  "{CALLED ON NULL INPUT | RETURNS NULL ON NULL INPUT | STRICT}\n"
					  "|    {IMMUTABLE | STABLE | VOLATILE}\n"
					  "|    {NOT FENCED | FENCED}\n"
					  "|    [ NOT ] LEAKPROOF\n"
					  "|    {[ EXTERNAL ] SECURITY INVOKER | [ EXTERNAL ] SECURITY DEFINER}\n"
					  "|    AUTHID { DEFINER | CURRENT_USER }\n"
					  "|    COST execution_cost\n"
					  "|    ROWS result_rows\n"
					  "|    SET configuration_parameter {{ TO | = } { value | DEFAULT }| FROM CURRENT}\n"
					  "|    RESET {configuration_parameter| ALL}");
}

void
sql_help_ALTER_GROUP(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "ALTER GROUP group_name\n"
					  "    ADD USER user_name [, ... ];\n"
					  "ALTER GROUP group_name\n"
					  "    DROP USER user_name [, ... ];\n"
					  "ALTER GROUP group_name\n"
					  "   RENAME TO new_name;");
}

void
sql_help_ALTER_INDEX(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "ALTER INDEX [ IF EXISTS ] index_name \n"
					  "    RENAME TO new_name;\n"
					  "ALTER INDEX [ IF EXISTS ] index_name \n"
					  "    SET TABLESPACE tablespace_name;\n"
					  "ALTER INDEX [ IF EXISTS ] index_name \n"
					  "    SET ( {storage_parameter = value} [, ... ] );\n"
					  "ALTER INDEX [ IF EXISTS ] index_name \n"
					  "    RESET ( storage_parameter [, ... ] ) ;\n"
					  "ALTER INDEX [ IF EXISTS ] index_name \n"
					  "    [ MODIFY PARTITION partition_name ] UNUSABLE;\n"
					  "ALTER INDEX index_name \n"
					  "    REBUILD [ PARTITION partition_name ];\n"
					  "ALTER INDEX [ IF EXISTS ] index_name \n"
					  "    RENAME PARTITION partition_name TO new_partition_name;\n"
					  "ALTER INDEX [ IF EXISTS ] index_name \n"
					  "    MOVE PARTITION index_partition_name TABLESPACE new_tablespace;");
}

void
sql_help_ALTER_LARGE_OBJECT(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "ALTER LARGE OBJECT large_object_oid\n"
					  "    OWNER TO new_owner;");
}

void
sql_help_ALTER_MASKING_POLICY(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "ALTER MASKING POLICY policy_name { ADD | REMOVE | MODIFY } masking_actions [, ... ];\n"
					  "ALTER MASKING POLICY policy_name MODIFY ( filter_group_clause ); \n"
					  "ALTER MASKING POLICY policy_name DROP FILTER; \n"
					  "ALTER MASKING POLICY policy_name { ENABLE | DISABLE }; \n"
					  "\n"
					  "where masking_actions can be:\n"
					  "masking_function ON LABEL(label_name [, ... ])\n"
					  "\n"
					  "where masking_function can be:\n"
					  "{ maskall | randommasking | creditcardmasking | basicemailmasking | fullemailmasking | shufflemasking | alldigitsmasking }\n"
					  "\n"
					  "where filter_group_clause can be:\n"
					  "FILTER ON { ( FILTER_TYPE ( filter_value [, ... ] ) ) [, ... ] }");
}

void
sql_help_ALTER_NODE(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "ALTER NODE nodename WITH\n"
					  "  (\n"
					  "    [ TYPE = nodetype,]\n"
					  "    [ HOST = hostname,]\n"
					  "    [ PORT = portnum,]\n"
					  "    [ HOST1 = 'hostname',]\n"
					  "    [ PORT1 = portnum,]\n"
					  "    [ HOSTPRIMARY [ = boolean ],]\n"
					  "    [ PRIMARY [ = boolean ],]\n"
					  "    [ PREFERRED [ = boolean ],]\n"
					  "    [ SCTP_PORT = portnum,]\n"
					  "    [ CONTROL_PORT = portnum,]\n"
					  "    [ SCTP_PORT1 = portnum,]\n"
					  "    [ CONTROL_PORT1 = portnum, ]\n"
					  "    [ NODEIS_CENTRAL [= boolean], ]\n"
					  "    [ NODEIS_ACTIVE [= boolean] ]\n"
					  "  );");
}

void
sql_help_ALTER_NODE_GROUP(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "ALTER NODE GROUP groupname [ option ]\n"
					  "\n"
					  "where option can be:\n"
					  "SET DEFAULT\n"
					  "    | RENAME TO new_group_name\n"
					  "    | SET VCGROUP RENAME TO new_group_name\n"
					  "    | SET NOT VCGROUP\n"
					  "    | SET TABLE GROUP new_group_name\n"
					  "    | COPY BUCKETS FROM src_group_name\n"
					  "    | ADD NODE ( nodename [, ... ] ) \n"
					  "    | DELETE NODE ( nodename [, ... ] )\n"
					  "    | RESIZE TO dest_group_name\n"
					  "    | SET VCGROUP WITH GROUP new_group_name");
}

void
sql_help_ALTER_RESOURCE_LABEL(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "ALTER RESOURCE LABEL label_name { ADD | REMOVE } label_item_list [, ... ];\n"
					  "\n"
					  "where label_item_list can be:\n"
					  "resource_type(resource_path[, ... ])\n"
					  "\n"
					  "where resource_type can be:\n"
					  "{ TABLE | COLUMN | SCHEMA | VIEW | FUNCTION }");
}

void
sql_help_ALTER_RESOURCE_POOL(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "ALTER RESOURCE POOL pool_name\n"
					  "    WITH ({MEM_PERCENT=pct | CONTROL_GROUP=\"group_name\" | ACTIVE_STATEMENTS=stmt | MAX_DOP = dop | MEMORY_LIMIT='memory_size' | io_limits=io_limits | io_priority='priority' | nodegroup='nodegroup_name' }[, ... ]);");
}

void
sql_help_ALTER_ROLE(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "ALTER ROLE role_name [ [ WITH ] option [ ... ] ];\n"
					  "ALTER ROLE role_name\n"
					  "    RENAME TO new_name;\n"
					  "ALTER ROLE role_name [ IN DATABASE database_name ]\n"
					  "    SET configuration_parameter {{ TO | = } { value | DEFAULT }|FROM CURRENT};\n"
					  "ALTER ROLE role_name\n"
					  "    [ IN DATABASE database_name ] RESET {configuration_parameter|ALL};\n"
					  "\n"
					  "where option can be:\n"
					  "{CREATEDB | NOCREATEDB}\n"
					  "    | {CREATEROLE | NOCREATEROLE}\n"
					  "    | {INHERIT | NOINHERIT}\n"
					  "    | {AUDITADMIN | NOAUDITADMIN}\n"
					  "    | {SYSADMIN | NOSYSADMIN}\n"
					  "    | {MONADMIN | NOMONADMIN}\n"
					  "    | {OPRADMIN | NOOPRADMIN}\n"
					  "    | {POLADMIN | NOPOLADMIN}\n"
					  "    | {USEFT | NOUSEFT}\n"
					  "    | {LOGIN | NOLOGIN}\n"
					  "    | {REPLICATION | NOREPLICATION}\n"
					  "    | {INDEPENDENT | NOINDEPENDENT}\n"
					  "    | {VCADMIN | NOVCADMIN}\n"
					  "    | {PERSISTENCE | NOPERSISTENCE}\n"
					  "    | CONNECTION LIMIT connlimit\n"
					  "    | [ ENCRYPTED | UNENCRYPTED ] PASSWORD { 'password' [ EXPIRED ] | DISABLE | EXPIRED }\n"
					  "    | [ ENCRYPTED | UNENCRYPTED ] IDENTIFIED BY { 'password' [ REPLACE 'old_password' | EXPIRED ] | DISABLE }\n"
					  "    | VALID BEGIN 'timestamp'\n"
					  "    | VALID UNTIL 'timestamp'\n"
					  "    | RESOURCE POOL 'respool'\n"
					  "    | USER GROUP 'groupuser'\n"
					  "    | PERM SPACE 'spacelimit'\n"
					  "    | TEMP SPACE 'tmpspacelimit'\n"
					  "    | SPILL SPACE 'spillspacelimit'\n"
					  "    | NODE GROUP logic_cluster_name\n"
					  "    | ACCOUNT { LOCK | UNLOCK }\n"
					  "    | PGUSER");
}

void
sql_help_ALTER_ROW_LEVEL_SECURITY_POLICY(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "ALTER [ ROW LEVEL SECURITY ] POLICY [ IF EXISTS ] policy_name ON table_name RENAME TO new_policy_name\n"
					  "\n"
					  "ALTER [ ROW LEVEL SECURITY ] POLICY policy_name ON table_name\n"
					  "    [ TO { role_name | PUBLIC } [, ...] ]\n"
					  "    [ USING ( using_expression ) ]");
}

void
sql_help_ALTER_SCHEMA(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "ALTER SCHEMA schema_name\n"
					  "    RENAME TO new_name;\n"
					  "ALTER SCHEMA schema_name\n"
					  "    OWNER TO new_owner;");
}

void
sql_help_ALTER_SEQUENCE(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "ALTER SEQUENCE [ IF EXISTS ] %s \n"
					  "    [ MAXVALUE %s | NO MAXVALUE | NOMAXVALUE ]\n"
					  "    [ OWNED BY { %s.%s | NONE } ];\n"
					  "ALTER SEQUENCE [ IF EXISTS ] %s OWNER TO %s;",
					  _("name"),
					  _("maxvalue"),
					  _("table_name"),
					  _("column_name"),
					  _("name"),
					  _("new_owner"));
}

void
sql_help_ALTER_SERVER(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "ALTER SERVER server_name [ VERSION 'new_version' ]\n"
					  "    [ OPTIONS ( {[ ADD | SET | DROP ] option ['value']} [, ... ] ) ];\n"
					  "ALTER SERVER server_name \n"
					  "    OWNER TO new_owner;\n"
					  "ALTER SERVER server_name\n"
					  "     RENAME TO new_name;");
}

void
sql_help_ALTER_SESSION(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "ALTER SESSION SET \n"
					  "    {{config_parameter { { TO  | =  }  { value | DEFAULT }\n"
					  "      | FROM CURRENT }} | CURRENT_SCHEMA [ TO | = ] { schema | DEFAULT }\n"
					  "      | TIME ZONE time_zone\n"
					  "      | SCHEMA schema\n"
					  "      | NAMES encoding_name\n"
					  "      | ROLE role_name PASSWORD 'password'\n"
					  "      | SESSION AUTHORIZATION { role_name PASSWORD 'password' | DEFAULT }\n"
					  "      | XML OPTION { DOCUMENT | CONTENT }\n"
					  "    } ;\n"
					  "ALTER SESSION SET [ SESSION CHARACTERISTICS AS ] TRANSACTION\n"
					  "    { ISOLATION LEVEL  {  READ COMMITTED  | READ UNCOMMITTED  }  |  { READ ONLY  | READ WRITE  }  } [, ...] ;");
}

void
sql_help_ALTER_SYNONYM(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "ALTER SYNONYM synonym_name\n"
					  "    OWNER TO new_owner;");
}

void
sql_help_ALTER_SYSTEM_KILL_SESSION(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "ALTER SYSTEM KILL SESSION 'session_sid, serial' [ IMMEDIATE ];");
}

void
sql_help_ALTER_SYSTEM_SET(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "ALTER SYSTEM SET { GUC_name } TO { GUC_value };");
}

void
sql_help_ALTER_TABLE(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "ALTER TABLE [ IF EXISTS ] { table_name  [*] | ONLY table_name | ONLY ( table_name  )}\n"
					  "    action [, ... ];\n"
					  "ALTER TABLE [ IF EXISTS ] table_name\n"
					  "    ADD ( { column_name data_type [ compress_mode ] [ COLLATE collation ] [ column_constraint [ ... ] ]} [, ...] );\n"
					  "ALTER TABLE [ IF EXISTS ] table_name\n"
					  "    MODIFY ( { column_name data_type | column_name [ CONSTRAINT constraint_name ] NOT NULL [ ENABLE ] | column_name [ CONSTRAINT constraint_name ] NULL } [, ...] );\n"
					  "ALTER TABLE [ IF EXISTS ] table_name\n"
					  "    RENAME TO new_table_name;\n"
					  "ALTER TABLE [ IF EXISTS ] { table_name  [*] | ONLY table_name | ONLY ( table_name  )}\n"
					  "    RENAME [ COLUMN ] column_name TO new_column_name;\n"
					  "ALTER TABLE [ IF EXISTS ] { table_name  [*] | ONLY table_name | ONLY ( table_name  )}\n"
					  "    RENAME CONSTRAINT constraint_name TO new_constraint_name;\n"
					  "ALTER TABLE [ IF EXISTS ] table_name\n"
					  "    SET SCHEMA new_schema;\n"
					  "\n"
					  "where action can be:\n"
					  "column_clause \n"
					  "    | ADD table_constraint [ NOT VALID ]\n"
					  "    | ADD table_constraint_using_index\n"
					  "    | VALIDATE CONSTRAINT constraint_name\n"
					  "    | DROP CONSTRAINT [ IF EXISTS ]  constraint_name [ RESTRICT | CASCADE ]\n"
					  "    | CLUSTER ON index_name\n"
					  "    | SET WITHOUT CLUSTER\n"
					  "    | SET ( {storage_parameter = value} [, ... ] )\n"
					  "    | RESET ( storage_parameter [, ... ] )\n"
					  "    | OWNER TO new_owner\n"
					  "    | SET TABLESPACE new_tablespace\n"
					  "    | SET {COMPRESS|NOCOMPRESS}\n"
					  "    | TO { GROUP groupname | NODE ( nodename [, ... ] ) }\n"
					  "    | ADD NODE ( nodename [, ... ] )\n"
					  "    | DELETE NODE ( nodename [, ... ] )\n"
					  "    | DISABLE TRIGGER [ trigger_name | ALL | USER ]\n"
					  "    | ENABLE TRIGGER [ trigger_name | ALL | USER ]\n"
					  "    | ENABLE REPLICA TRIGGER trigger_name\n"
					  "    | ENABLE ALWAYS TRIGGER trigger_name\n"
					  "    | ENABLE ROW LEVEL SECURITY\n"
					  "    | DISABLE ROW LEVEL SECURITY\n"
					  "    | FORCE ROW LEVEL SECURITY\n"
					  "    | NO FORCE ROW LEVEL SECURITY\n"
					  "where column_clause can be:\n"
					  "ADD [ COLUMN ] column_name data_type [ compress_mode ] [ COLLATE collation ] [ column_constraint [ ... ] ]\n"
					  "    | MODIFY column_name data_type\n"
					  "    | MODIFY column_name [ CONSTRAINT constraint_name ] NOT NULL [ ENABLE ]\n"
					  "    | MODIFY column_name [ CONSTRAINT constraint_name ] NULL\n"
					  "    | DROP [ COLUMN ] [ IF EXISTS ] column_name [ RESTRICT | CASCADE ]\n"
					  "    | ALTER [ COLUMN ] column_name [ SET DATA ] TYPE data_type [ COLLATE collation ] [ USING expression ]\n"
					  "    | ALTER [ COLUMN ] column_name { SET DEFAULT expression | DROP DEFAULT }\n"
					  "    | ALTER [ COLUMN ] column_name { SET | DROP } NOT NULL\n"
					  "    | ALTER [ COLUMN ] column_name SET STATISTICS [PERCENT] integer\n"
					  "    | ADD STATISTICS (( column_1_name, column_2_name [, ...] ))\n"
					  "    | DELETE STATISTICS (( column_1_name, column_2_name [, ...] ))\n"
					  "    | ALTER [ COLUMN ] column_name SET ( {attribute_option = value} [, ... ] )\n"
					  "    | ALTER [ COLUMN ] column_name RESET ( attribute_option [, ... ] )\n"
					  "    | ALTER [ COLUMN ] column_name SET STORAGE { PLAIN | EXTERNAL | EXTENDED | MAIN }\n"
					  "where column_constraint can be:\n"
					  "[ CONSTRAINT constraint_name ]\n"
					  "    { NOT NULL |\n"
					  "      NULL |\n"
					  "      CHECK ( expression ) |\n"
					  "      DEFAULT default_expr |\n"
					  "      UNIQUE index_parameters |\n"
					  "      PRIMARY KEY index_parameters |\n"
					  "      REFERENCES reftable [ ( refcolumn ) ] [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ]\n"
					  "        [ ON DELETE action ] [ ON UPDATE action ] }\n"
					  "    [ DEFERRABLE | NOT DEFERRABLE | INITIALLY DEFERRED | INITIALLY IMMEDIATE ]\n"
					  "where compress_mode can be:\n"
					  "{ DELTA | PREFIX | DICTIONARY | NUMSTR | NOCOMPRESS }\n"
					  "where table_constraint can be:\n"
					  "[ CONSTRAINT constraint_name ]\n"
					  "    { CHECK ( expression ) |\n"
					  "      UNIQUE ( column_name [, ... ] ) index_parameters |\n"
					  "      PRIMARY KEY ( column_name [, ... ] ) index_parameters |\n"
					  "      PARTIAL CLUSTER KEY ( column_name [, ... ] ) |\n"
					  "      FOREIGN KEY ( column_name [, ... ] ) REFERENCES reftable [ ( refcolumn [, ... ] ) ]\n"
					  "        [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ] [ ON DELETE action ] [ ON UPDATE action ] }\n"
					  "    [ DEFERRABLE | NOT DEFERRABLE | INITIALLY DEFERRED | INITIALLY IMMEDIATE ]\n"
					  "where index_parameters can be:\n"
					  "[ WITH ( {storage_parameter = value} [, ... ] ) ]\n"
					  "    [ USING INDEX TABLESPACE tablespace_name ]\n"
					  "where table_constraint_using_index can be:\n"
					  "[ CONSTRAINT constraint_name ]\n"
					  "    { UNIQUE | PRIMARY KEY } USING INDEX index_name\n"
					  "    [ DEFERRABLE | NOT DEFERRABLE | INITIALLY DEFERRED | INITIALLY IMMEDIATE ]");
}

void
sql_help_ALTER_TABLE_PARTITION(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "ALTER TABLE [ IF EXISTS ] { table_name  [*] | ONLY table_name | ONLY ( table_name  )}\n"
					  "    action [, ... ];\n"
					  "ALTER TABLE [ IF EXISTS ] { table_name [*] | ONLY table_name | ONLY ( table_name  )}\n"
					  "    RENAME PARTITION { partion_name | FOR ( partition_value [, ...] ) } TO partition_new_name;\n"
					  "\n"
					  "where action can be:\n"
					  "move_clause  |\n"
					  "    exchange_clause  |\n"
					  "    row_clause  |\n"
					  "    merge_clause  |\n"
					  "    modify_clause  |\n"
					  "    split_clause  |\n"
					  "    add_clause  |\n"
					  "    drop_clause\n"
					  "where move_clause can be:\n"
					  "MOVE PARTITION { partion_name | FOR ( partition_value [, ...] ) } TABLESPACE tablespacename\n"
					  "where exchange_clause can be:\n"
					  "EXCHANGE PARTITION { ( partition_name ) | FOR ( partition_value [, ...] ) } \n"
					  "    WITH TABLE {[ ONLY ] ordinary_table_name | ordinary_table_name * | ONLY ( ordinary_table_name )} \n"
					  "    [ { WITH | WITHOUT } VALIDATION ] [ VERBOSE ]\n"
					  "where row_clause can be:\n"
					  "{ ENABLE | DISABLE } ROW MOVEMENT\n"
					  "where merge_clause can be:\n"
					  "MERGE PARTITIONS { partition_name } [, ...] INTO PARTITION partition_name\n"
					  "    [ TABLESPACE tablespacename ]\n"
					  "where modify_clause can be:\n"
					  "MODIFY PARTITION partition_name { UNUSABLE LOCAL INDEXES | REBUILD UNUSABLE LOCAL INDEXES }\n"
					  "where split_clause can be:\n"
					  "SPLIT PARTITION { partition_name | FOR ( partition_value [, ...] ) } { split_point_clause | no_split_point_clause }\n"
					  "where split_point_clause can be:\n"
					  "AT ( partition_value ) INTO ( PARTITION partition_name [ TABLESPACE tablespacename ] , PARTITION partition_name [ TABLESPACE tablespacename ] )\n"
					  "where no_split_point_clause can be:\n"
					  "INTO {(partition_less_than_item [, ...] ) | (partition_start_end_item [, ...] )}\n"
					  "where add_clause can be:\n"
					  "ADD {partition_less_than_item | partition_start_end_item}\n"
					  "where partition_less_than_item can be:\n"
					  "PARTITION partition_name VALUES LESS THAN ( { partition_value | MAXVALUE }	[, ...] ) [ TABLESPACE tablespacename ]\n"
					  "where partition_start_end_item can be:\n"
					  "PARTITION partition_name {\n"
					  "	{START(partition_value) END (partition_value) EVERY (interval_value)} |\n"
					  "	{START(partition_value) END ({partition_value | MAXVALUE})} |\n"
					  "	{START(partition_value)} |\n"
					  "	{END({partition_value | MAXVALUE})}\n"
					  "} [TABLESPACE tablespace_name]\n"
					  "where drop_clause can be:\n"
					  "DROP PARTITION  { partition_name  | FOR (  partition_value [, ...] )  }");
}

void
sql_help_ALTER_TABLESPACE(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "ALTER TABLESPACE tablespace_name\n"
					  "    RENAME TO new_tablespace_name;\n"
					  "ALTER TABLESPACE tablespace_name\n"
					  "    OWNER TO new_owner;\n"
					  "ALTER TABLESPACE tablespace_name\n"
					  "    SET ( {tablespace_option = value} [, ... ] );\n"
					  "ALTER TABLESPACE tablespace_name\n"
					  "    RESET ( tablespace_option [, ... ] );\n"
					  "ALTER TABLESPACE tablespace_name\n"
					  "    RESIZE MAXSIZE { UNLIMITED | 'space_size' };");
}

void
sql_help_ALTER_TEXT_SEARCH_CONFIGURATION(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "ALTER TEXT SEARCH CONFIGURATION %s\n"
					  "    ADD MAPPING FOR %s [, ... ] WITH %s [, ... ]\n"
					  "ALTER TEXT SEARCH CONFIGURATION %s\n"
					  "    ALTER MAPPING FOR %s [, ... ] WITH %s [, ... ]\n"
					  "ALTER TEXT SEARCH CONFIGURATION %s\n"
					  "    ALTER MAPPING REPLACE %s WITH %s\n"
					  "ALTER TEXT SEARCH CONFIGURATION %s\n"
					  "    ALTER MAPPING FOR %s [, ... ] REPLACE %s WITH %s\n"
					  "ALTER TEXT SEARCH CONFIGURATION %s\n"
					  "    DROP MAPPING [ IF EXISTS ] FOR %s [, ... ]\n"
					  "ALTER TEXT SEARCH CONFIGURATION %s RENAME TO %s\n"
					  "ALTER TEXT SEARCH CONFIGURATION %s OWNER TO %s\n"
					  "ALTER TEXT SEARCH CONFIGURATION %s SET SCHEMA %s\n"
					  "ALTER TEXT SEARCH CONFIGURATION %s SET %s\n"
					  "ALTER TEXT SEARCH CONFIGURATION %s RESET %s",
					  _("name"),
					  _("token_type"),
					  _("dictionary_name"),
					  _("name"),
					  _("token_type"),
					  _("dictionary_name"),
					  _("name"),
					  _("old_dictionary"),
					  _("new_dictionary"),
					  _("name"),
					  _("token_type"),
					  _("old_dictionary"),
					  _("new_dictionary"),
					  _("name"),
					  _("token_type"),
					  _("name"),
					  _("new_name"),
					  _("name"),
					  _("new_owner"),
					  _("name"),
					  _("new_schema"),
					  _("name"),
					  _("( {configuration_option = value} [, ...] )"),
					  _("name"),
					  _("( {configuration_option} [, ...] )"));
}

void
sql_help_ALTER_TEXT_SEARCH_DICTIONARY(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "ALTER TEXT SEARCH DICTIONARY name ( option = value | option [, ...] );\n"
					  "ALTER TEXT SEARCH DICTIONARY name RENAME TO new_name;\n"
					  "ALTER TEXT SEARCH DICTIONARY name OWNER TO new_owner;\n"
					  "ALTER TEXT SEARCH DICTIONARY name SET SCHEMA new_schema;");
}

void
sql_help_ALTER_TRIGGER(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "ALTER TRIGGER name ON table_name RENAME TO new_name");
}

void
sql_help_ALTER_TYPE(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "ALTER TYPE %s %s [, ... ]\n"
					  "ALTER TYPE %s OWNER TO { %s | CURRENT_USER | SESSION_USER }\n"
					  "ALTER TYPE %s RENAME ATTRIBUTE %s TO %s [ CASCADE | RESTRICT ]\n"
					  "ALTER TYPE %s RENAME TO %s\n"
					  "ALTER TYPE %s SET SCHEMA %s\n"
					  "ALTER TYPE %s ADD VALUE [ IF NOT EXISTS ] %s [ { BEFORE | AFTER } %s ]\n"
					  "ALTER TYPE %s RENAME VALUE %s TO %s\n"
					  "\n"
					  "%s\n"
					  "\n"
					  "    ADD ATTRIBUTE %s %s [ COLLATE %s ] [ CASCADE | RESTRICT ]\n"
					  "    DROP ATTRIBUTE [ IF EXISTS ] %s [ CASCADE | RESTRICT ]\n"
					  "    ALTER ATTRIBUTE %s [ SET DATA ] TYPE %s [ COLLATE %s ] [ CASCADE | RESTRICT ]",
					  _("name"),
					  _("action"),
					  _("name"),
					  _("new_owner"),
					  _("name"),
					  _("attribute_name"),
					  _("new_attribute_name"),
					  _("name"),
					  _("new_name"),
					  _("name"),
					  _("new_schema"),
					  _("name"),
					  _("new_enum_value"),
					  _("neighbor_enum_value"),
					  _("name"),
					  _("existing_enum_value"),
					  _("new_enum_value"),
					  _("where action is one of:"),
					  _("attribute_name"),
					  _("data_type"),
					  _("collation"),
					  _("attribute_name"),
					  _("attribute_name"),
					  _("data_type"),
					  _("collation"));
}

void
sql_help_ALTER_USER(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "ALTER USER user_name [ [ WITH ] option [ ... ] ];\n"
					  "ALTER USER user_name\n"
					  "    RENAME TO new_name;\n"
					  "ALTER USER user_name [ IN DATABASE database_name ]\n"
					  "    SET configuration_parameter {{ TO | = } { value | DEFAULT }|FROM CURRENT};\n"
					  "ALTER USER user_name\n"
					  "    [ IN DATABASE database_name ] RESET {configuration_parameter|ALL};\n"
					  "\n"
					  "where option can be:\n"
					  "{CREATEDB | NOCREATEDB}\n"
					  "    | {CREATEROLE | NOCREATEROLE}\n"
					  "    | {INHERIT | NOINHERIT}\n"
					  "    | {AUDITADMIN | NOAUDITADMIN}\n"
					  "    | {SYSADMIN | NOSYSADMIN}\n"
					  "    | {MONADMIN | NOMONADMIN}\n"
					  "    | {OPRADMIN | NOOPRADMIN}\n"
					  "    | {POLADMIN | NOPOLADMIN}\n"
					  "    | {USEFT | NOUSEFT}\n"
					  "    | {LOGIN | NOLOGIN}\n"
					  "    | {REPLICATION | NOREPLICATION}\n"
					  "    | {INDEPENDENT | NOINDEPENDENT}\n"
					  "    | {VCADMIN | NOVCADMIN}\n"
					  "    | {PERSISTENCE | NOPERSISTENCE}\n"
					  "    | CONNECTION LIMIT connlimit\n"
					  "    | [ ENCRYPTED | UNENCRYPTED ] PASSWORD { 'password' [ EXPIRED ] | DISABLE | EXPIRED }\n"
					  "    | [ ENCRYPTED | UNENCRYPTED ] IDENTIFIED BY { 'password' [ REPLACE 'old_password' | EXPIRED ] | DISABLE }\n"
					  "    | VALID BEGIN 'timestamp'\n"
					  "    | VALID UNTIL 'timestamp'\n"
					  "    | RESOURCE POOL 'respool'\n"
					  "    | USER GROUP 'groupuser'\n"
					  "    | PERM SPACE 'spacelimit'\n"
					  "    | TEMP SPACE 'tmpspacelimit'\n"
					  "    | SPILL SPACE 'spillspacelimit'\n"
					  "    | NODE GROUP logic_cluster_name\n"
					  "    | ACCOUNT { LOCK | UNLOCK }\n"
					  "    | PGUSER");
}

void
sql_help_ALTER_VIEW(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "ALTER VIEW [ IF EXISTS ] view_name\n"
					  "    ALTER [ COLUMN ] column_name SET DEFAULT expression;\n"
					  "ALTER VIEW [ IF EXISTS ] view_name\n"
					  "    ALTER [ COLUMN ] column_name DROP DEFAULT;\n"
					  "ALTER VIEW [ IF EXISTS ] view_name\n"
					  "    OWNER TO new_owner;\n"
					  "ALTER VIEW [ IF EXISTS ] view_name\n"
					  "    RENAME TO new_name;\n"
					  "ALTER VIEW [ IF EXISTS ] view_name\n"
					  "    SET SCHEMA new_schema;\n"
					  "ALTER VIEW [ IF EXISTS ] view_name\n"
					  "    SET ( {view_option_name [= view_option_value]} [, ... ] );\n"
					  "ALTER VIEW [ IF EXISTS ] view_name\n"
					  "    RESET ( view_option_name [, ... ] );");
}

void
sql_help_ALTER_WORKLOAD_GROUP(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "ALTER WORKLOAD GROUP wg_name\n"
					  "     USING RESOURCE POOL pool_name [ WITH ( ACT_STATEMENTS = count ) ];");
}

void
sql_help_ANALYSE(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "{ANALYZE | ANALYSE} [ VERBOSE ]\n"
					  "    [ table_name [ ( column_name [, ...] ) ] ];\n"
					  "{ANALYZE | ANALYSE} [ VERBOSE ]\n"
					  "    [ table_name [ ( column_name [, ...] ) ] ]\n"
					  "    PARTITION patrition_name;\n"
					  "{ANALYZE | ANALYSE} [ VERBOSE ]\n"
					  "    { foreign_table_name | FOREIGN TABLES };\n"
					  "{ANALYZE | ANALYSE} [ VERBOSE ]\n"
					  "    table_name (( column_1_name, column_2_name [, ...] ));\n"
					  "{ANALYZE | ANALYSE} VERIFY {FAST|COMPLETE};\n"
					  "{ANALYZE | ANALYSE} VERIFY {FAST|COMPLETE}\n"
					  "    table_name|index_name [CASCADE];\n"
					  "{ANALYZE | ANALYSE} VERIFY {FAST|COMPLETE}\n"
					  "    table_name PARTITION (patrition_name) [CASCADE];");
}

void
sql_help_ANALYZE(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "{ANALYZE | ANALYSE} [ VERBOSE ]\n"
					  "    [ table_name [ ( column_name [, ...] ) ] ];\n"
					  "{ANALYZE | ANALYSE} [ VERBOSE ]\n"
					  "    [ table_name [ ( column_name [, ...] ) ] ]\n"
					  "    PARTITION patrition_name;\n"
					  "{ANALYZE | ANALYSE} [ VERBOSE ]\n"
					  "    { foreign_table_name | FOREIGN TABLES };\n"
					  "{ANALYZE | ANALYSE} [ VERBOSE ]\n"
					  "    table_name (( column_1_name, column_2_name [, ...] ));\n"
					  "{ANALYZE | ANALYSE} VERIFY {FAST|COMPLETE};\n"
					  "{ANALYZE | ANALYSE} VERIFY {FAST|COMPLETE}\n"
					  "    table_name|index_name [CASCADE];\n"
					  "{ANALYZE | ANALYSE} VERIFY {FAST|COMPLETE}\n"
					  "    table_name PARTITION (patrition_name) [CASCADE];");
}

void
sql_help_ANONYMOUS_BLOCK(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "[DECLARE [declare_statements]] \n"
					  "	BEGIN\n"
					  "	execution_staements  \n"
					  "	END;\n"
					  "	/");
}

void
sql_help_BEGIN(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "start a anonymous block:\n"
					  "[DECLARE [declare_statements]] \n"
					  "BEGIN\n"
					  "execution_statements\n"
					  "END;\n"
					  "/\n"
					  "\n"
					  "start a transaction:\n"
					  "BEGIN [ WORK | TRANSACTION ]\n"
					  "  [ \n"
					  "    { \n"
					  "       ISOLATION LEVEL { READ COMMITTED | READ UNCOMMITTED | SERIALIZABLE | REPEATABLE READ }\n"
					  "       | { READ WRITE | READ ONLY }\n"
					  "      } [, ...] \n"
					  "  ];");
}

void
sql_help_CALL(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "CALL [schema.] func_name ( param_expr );");
}

void
sql_help_CHECKPOINT(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "CHECKPOINT");
}

void
sql_help_CLEAN_CONNECTION(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "CLEAN CONNECTION\n"
					  "    TO { COORDINATOR ( nodename [, ... ] ) | NODE ( nodename [, ... ] ) | ALL [ CHECK ] [ FORCE ] }\n"
					  "    [ FOR DATABASE dbname ]\n"
					  "    [ TO USER username ];");
}

void
sql_help_CLOSE(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "CLOSE { cursor_name | ALL };");
}

void
sql_help_CLUSTER(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "CLUSTER [ VERBOSE ] table_name [ USING index_name ];\n"
					  "CLUSTER [ VERBOSE ] table_name PARTITION ( partition_name ) [ USING index_name ];\n"
					  "CLUSTER [ VERBOSE ];");
}

void
sql_help_COMMENT(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "COMMENT ON\n"
					  "{\n"
					  "  AGGREGATE agg_name (agg_type [, ...] ) |\n"
					  "  CAST (source_type AS target_type) |\n"
					  "  COLLATION object_name |\n"
					  "  COLUMN { table_name.column_name | view_name.column_name } |\n"
					  "  CONSTRAINT constraint_name ON table_name |\n"
					  "  CONVERSION object_name |\n"
					  "  DATABASE object_name |\n"
					  "  DOMAIN object_name |\n"
					  "  EXTENSION object_name |\n"
					  "  FOREIGN DATA WRAPPER object_name |\n"
					  "  FOREIGN TABLE object_name |\n"
					  "  FUNCTION function_name ( [ {[ argmode ] [ argname ] argtype} [, ...] ] ) |\n"
					  "  INDEX object_name |\n"
					  "  LARGE OBJECT large_object_oid |\n"
					  "  OPERATOR operator_name (left_type, right_type) |\n"
					  "  OPERATOR CLASS object_name USING index_method |\n"
					  "  OPERATOR FAMILY object_name USING index_method |\n"
					  "  [ PROCEDURAL ] LANGUAGE object_name |\n"
					  "  ROLE object_name |\n"
					  "  RULE rule_name ON table_name |\n"
					  "  SCHEMA object_name |\n"
					  "  SERVER object_name |\n"
					  "  TABLE object_name |\n"
					  "  TABLESPACE object_name |\n"
					  "  TEXT SEARCH CONFIGURATION object_name |\n"
					  "  TEXT SEARCH DICTIONARY object_name |\n"
					  "  TEXT SEARCH PARSER object_name |\n"
					  "  TEXT SEARCH TEMPLATE object_name |\n"
					  "  TYPE object_name |\n"
					  "  VIEW object_name\n"
					  "}\n"
					  "   IS 'text';");
}

void
sql_help_COMMIT(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "{ COMMIT | END } [ WORK | TRANSACTION ];");
}

void
sql_help_COMMIT_PREPARED(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "COMMIT PREPARED transaction_id;");
}

void
sql_help_COPY(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "COPY table_name [ ( column_name [, ...] ) ]\n"
					  "    FROM { 'filename' | STDIN }\n"
					  "    [ [ USING ] DELIMITERS 'delimiters' ]\n"
					  "    [ WITHOUT ESCAPING ]\n"
					  "    [ LOG ERRORS ]\n"
					  "    [ LOG ERRORS DATA ]\n"
					  "    [ REJECT LIMIT 'limit' ]\n"
					  "    [ [ WITH ] ( option [, ...] ) ]\n"
					  "    | copy_option\n"
					  "    | [ FIXED FORMATTER ( { column_name( offset, length ) } [, ...] ) ];\n"
					  "COPY table_name [ ( column_name [, ...] ) ]\n"
					  "    TO { 'filename' | STDOUT }\n"
					  "    [ [ USING ] DELIMITERS 'delimiters' ]\n"
					  "    [ WITHOUT ESCAPING ]\n"
					  "    [ [ WITH ] ( option [, ...] ) ]\n"
					  "    | copy_option\n"
					  "    | [ FIXED FORMATTER ( { column_name( offset, length ) } [, ...] ) ];\n"
					  "COPY query\n"
					  "    TO { 'filename' | STDOUT }\n"
					  "    [ WITHOUT ESCAPING ]\n"
					  "    [ [ WITH ] ( option [, ...] ) ]\n"
					  "    | copy_option\n"
					  "    | [ FIXED FORMATTER ( { column_name( offset, length ) } [, ...] ) ];\n"
					  "\n"
					  "where option can be:\n"
					  "FORMAT 'format_name'\n"
					  "| OIDS [ boolean ]\n"
					  "| DELIMITER 'delimiter_character'\n"
					  "| NULL 'null_string'\n"
					  "| HEADER [ boolean ]\n"
					  "| FILEHEADER 'header_file_string'\n"
					  "| FREEZE [ boolean ]\n"
					  "| QUOTE 'quote_character'\n"
					  "| ESCAPE 'escape_character'\n"
					  "| EOL 'newline_character'\n"
					  "| NOESCAPING [ boolean ]\n"
					  "| FORCE_QUOTE { ( column_name [, ...] ) | * }\n"
					  "| FORCE_NOT_NULL ( column_name [, ...] )\n"
					  "| ENCODING 'encoding_name'\n"
					  "| IGNORE_EXTRA_DATA [ boolean ]\n"
					  "| FILL_MISSING_FIELDS [ boolean ]\n"
					  "| COMPATIBLE_ILLEGAL_CHARS [ boolean ]\n"
					  "| DATE_FORMAT 'date_format_string'\n"
					  "| TIME_FORMAT 'time_format_string'\n"
					  "| TIMESTAMP_FORMAT 'timestamp_format_string'\n"
					  "| SMALLDATETIME_FORMAT 'smalldatetime_format_string'\n"
					  "\n"
					  "and copy_option can be:\n"
					  "OIDS\n"
					  "| NULL 'null_string'\n"
					  "| HEADER\n"
					  "| FILEHEADER 'header_file_string'\n"
					  "| FREEZE\n"
					  "| FORCE NOT NULL column_name [, ...]\n"
					  "| FORCE QUOTE { column_name [, ...] | * }\n"
					  "| BINARY\n"
					  "| CSV\n"
					  "| QUOTE [ AS ] 'quote_character'\n"
					  "| ESCAPE [ AS ] 'escape_character'\n"
					  "| EOL 'newline_character'\n"
					  "| ENCODING 'encoding_name'\n"
					  "| IGNORE_EXTRA_DATA\n"
					  "| FILL_MISSING_FIELDS\n"
					  "| COMPATIBLE_ILLEGAL_CHARS\n"
					  "| DATE_FORMAT 'date_format_string'\n"
					  "| TIME_FORMAT 'time_format_string'\n"
					  "| TIMESTAMP_FORMAT 'timestamp_format_string'\n"
					  "| SMALLDATETIME_FORMAT 'smalldatetime_format_string'");
}

void
sql_help_CREATE_APP_WORKLOAD_GROUP(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "CREATE APP WORKLOAD GROUP MAPPING app_name [ WITH ( WORKLOAD_GPNAME  = workload_gpname ) ]");
}

void
sql_help_CREATE_APP_WORKLOAD_GROUP_MAPPING(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "CREATE APP WORKLOAD GROUP MAPPING app_name\n"
					  "    [ WITH ( WORKLOAD_GPNAME  = workload_gpname ) ];");
}

void
sql_help_CREATE_AUDIT_POLICY(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "CREATE AUDIT POLICY [ IF NOT EXISTS ] policy_name { { privilege_audit_clause | access_audit_clause } [ filter_group_clause ] [ ENABLED | DISABLED ] };\n"
					  "\n"
					  "where privilege_audit_clause can be:\n"
					  "PRIVILEGES { DDL | ALL } [ ON LABEL ( resource_label_name [, ... ] ) ]\n"
					  "\n"
					  "where access_audit_clause can be:\n"
					  "ACCESS { DML | ALL } [ ON LABEL ( resource_label_name [, ... ] ) ]\n"
					  "\n"
					  "where filter_group_clause can be:\n"
					  "FILTER ON { ( FILTER_TYPE ( filter_value [, ... ] ) ) [, ... ] }\n"
					  "\n"
					  "where DDL can be:\n"
					  "{ ( ALTER | ANALYZE | COMMENT | CREATE | DROP | GRANT | REVOKE | SET | SHOW | LOGIN_ACCESS | LOGIN_FAILURE | LOGOUT | LOGIN ) }\n"
					  "\n"
					  "where DML can be: \n"
					  "{ ( COPY | DEALLOCATE | DELETE_P | EXECUTE | REINDEX | INSERT | REPARE | SELECT | TRUNCATE | UPDATE ) }\n"
					  "\n"
					  "where FILTER_TYPE can be:\n"
					  "{ APP | ROLES | IP }");
}

void
sql_help_CREATE_BARRIER(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "CREATE BARRIER [ barrier_name ];");
}

void
sql_help_CREATE_CLIENT_MASTER_KEY(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "CREATE CLIENT MASTER KEY  \n"
					  "     [WITH] ( ['KEY_STORE' , 'KEY_PATH' , 'ALGORITHM'] );");
}

void
sql_help_CREATE_COLUMN_ENCRYPTION_KEY(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "CREATE COLUMN ENCRYPTION KEY \n"
					  "     [WITH] ( ['CLIENT_MASTER_KEY' , 'ALGORITHM'] );");
}

void
sql_help_CREATE_DATA_SOURCE(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "CREATE DATA SOURCE src_name\n"
					  "    [TYPE 'type_str']\n"
					  "    [VERSION {'version_str' | NULL}]\n"
					  "    [OPTIONS (optname 'optvalue' [, ...])];\n"
					  "\n"
					  "Valid optname are:\n"
					  "    DSN, USERNAME, PASSWORD, ENCODING");
}

void
sql_help_CREATE_DATABASE(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "CREATE DATABASE database_name\n"
					  "    [ [ WITH ] {[ OWNER [=] user_name ]|\n"
					  "           [ TEMPLATE [=] template ]|\n"
					  "           [ ENCODING [=] encoding ]|\n"
					  "           [ LC_COLLATE [=] lc_collate ]|\n"
					  "           [ LC_CTYPE [=] lc_ctype ]|\n"
					  "           [ DBCOMPATIBILITY [=] compatibility_type ]|\n"
					  "           [ TABLESPACE [=] tablespace_name ]|\n"
					  "           [ CONNECTION LIMIT [=] connlimit ]}[...] ];");
}

void
sql_help_CREATE_DIRECTORY(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "CREATE [OR REPLACE] DIRECTORY directory_name\n"
					  "AS 'path_name';");
}

void
sql_help_CREATE_EXTENSION(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "CREATE EXTENSION [ IF NOT EXISTS ] %s\n"
					  "    [ WITH ] [ SCHEMA %s ]\n"
					  "             [ VERSION %s ]\n"
					  "             [ FROM %s ];",
					  _("extension_name"),
					  _("schema_name"),
					  _("version"),
					  _("old_version"));
}

void
sql_help_CREATE_FOREIGN_TABLE(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "CREATE FOREIGN TABLE [ IF NOT EXISTS  ] table_name \n"
					  "( { column_name type_name POSITION(offset,length) [column_constraint ]\n"
					  "	| LIKE source_table | table_constraint } [, ...] ) \n"
					  "SEVER gsmpp_server \n"
					  "OPTIONS (  { option_name ' value '  }  [, ...] ) \n"
					  "[  { WRITE ONLY  |  READ ONLY  }] \n"
					  "[ WITH error_table_name | LOG INTO error_table_name] \n"
					  "[REMOTE LOG 'name'] \n"
					  "[PER NODE REJECT LIMIT 'value']\n"
					  "[ TO { GROUP groupname | NODE ( nodename [, ... ] ) } ];\n"
					  "CREATE FOREIGN TABLE [ IF NOT EXISTS ] table_name \n"
					  "( { column_name type_name \n"
					  "    [ { [CONSTRAINT constraint_name] NULL | \n"
					  "    [CONSTRAINT constraint_name] NOT NULL | \n"
					  "	column_constraint [...]} ] | \n"
					  "	table_constraint} [, ...] ) \n"
					  "SERVER server_name \n"
					  "OPTIONS ( { option_name ' value ' } [, ...] ) \n"
					  "DISTRIBUTE BY {ROUNDROBIN | REPLICATION}\n"
					  "[ TO { GROUP groupname | NODE ( nodename [, ... ] ) } ]\n"
					  "[ PARTITION BY ( column_name ) [AUTOMAPPED]] ;\n"
					  "CREATE FOREIGN TABLE [ IF NOT EXISTS ] table_name\n"
					  "( [ { column_name type_name | LIKE source_table } [, ...] ] )\n"
					  "SERVER server_name\n"
					  "OPTIONS ( { option_name ' value ' } [, ...] )\n"
					  "[ READ ONLY ]\n"
					  "[ DISTRIBUTE BY {ROUNDROBIN} ]\n"
					  "[ TO { GROUP groupname | NODE ( nodename [, ... ] ) } ];\n"
					  "\n"
					  "where column_constraint can be:\n"
					  "[CONSTRAINT constraint_name]\n"
					  "{PRIMARY KEY | UNIQUE}\n"
					  "[NOT ENFORCED [ENABLE QUERY OPTIMIZATION | DISABLE QUERY OPTIMIZATION] | ENFORCED]\n"
					  "where table_constraint can be:\n"
					  "[CONSTRAINT constraint_name]\n"
					  "{PRIMARY KEY | UNIQUE} (column_name)\n"
					  "[NOT ENFORCED [ENABLE QUERY OPTIMIZATION | DISABLE QUERY OPTIMIZATION] | ENFORCED]");
}

void
sql_help_CREATE_FUNCTION(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "CREATE [ OR REPLACE  ] FUNCTION function_name\n"
					  "    ( [  { argname [ argmode  ] argtype [  { DEFAULT  | :=  | =  } expression  ]}  [, ...]  ] )\n"
					  "    [ RETURNS rettype [ DETERMINISTIC  ]\n"
					  "        | RETURNS TABLE (  { column_name column_type  }  [, ...] )]\n"
					  "    LANGUAGE lang_name \n"
					  "    [  \n"
					  "        {IMMUTABLE  | STABLE  | VOLATILE}\n"
					  "        | {SHIPPABLE | NOT SHIPPABLE}\n"
					  "        | [ NOT  ] LEAKPROOF \n"
					  "        | WINDOW\n"
					  "        | {CALLED ON NULL INPUT | RETURNS NULL ON NULL INPUT | STRICT} \n"
					  "        | {[ EXTERNAL  ] SECURITY INVOKER  | [ EXTERNAL  ] SECURITY DEFINER | AUTHID DEFINER  | AUTHID CURRENT_USER} \n"
					  "        | {FENCED | NOT FENCED}\n"
					  "        | {PACKAGE}\n"
					  "        | COST execution_cost  \n"
					  "        | ROWS result_rows\n"
					  "        | SET configuration_parameter { {TO | =} value | FROM CURRENT }\n"
					  "    ] [...]\n"
					  "    {\n"
					  "        AS 'definition'\n"
					  "        | AS 'obj_file', 'link_symbol'\n"
					  "    }\n"
					  "\n"
					  "CREATE [ OR REPLACE  ] FUNCTION function_name\n"
					  "    ( [  { argname [ argmode  ] argtype [  { DEFAULT | := | =  } expression  ] }  [, ...]  ] )\n"
					  "    RETURN rettype [ DETERMINISTIC  ]\n"
					  "    [ \n"
					  "        {IMMUTABLE  | STABLE  | VOLATILE } \n"
					  "        | {SHIPPABLE | NOT SHIPPABLE}\n"
					  "        | {PACKAGE}\n"
					  "        | [ NOT  ] LEAKPROOF  \n"
					  "        | {CALLED ON NULL INPUT  | RETURNS NULL ON NULL INPUT  | STRICT } \n"
					  "        | {[ EXTERNAL  ] SECURITY INVOKER  | [ EXTERNAL  ] SECURITY DEFINER | | AUTHID DEFINER  | AUTHID CURRENT_USER}\n"
					  "        | COST execution_cost\n"
					  "        | ROWS result_rows\n"
					  "        | SET configuration_parameter { {TO | =} value | FROM CURRENT } \n"
					  "     ][...]\n"
					  "     { \n"
					  "        IS | AS  \n"
					  "     } plsql_body\n"
					  "/");
}

void
sql_help_CREATE_GROUP(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "CREATE GROUP group_name [ [ WITH ] option [ ... ] ] [ ENCRYPTED | UNENCRYPTED ] { PASSWORD | IDENTIFIED BY } { 'password' [ EXPIRED ] | DISABLE };\n"
					  "\n"
					  "where option can be:\n"
					  "{SYSADMIN | NOSYSADMIN}\n"
					  "    | {MONADMIN | NOMONADMIN}\n"
					  "    | {OPRADMIN | NOOPRADMIN}\n"
					  "    | {POLADMIN | NOPOLADMIN}\n"
					  "    | {AUDITADMIN | NOAUDITADMIN}\n"
					  "    | {CREATEDB | NOCREATEDB}\n"
					  "    | {USEFT | NOUSEFT}\n"
					  "    | {CREATEROLE | NOCREATEROLE}\n"
					  "    | {INHERIT | NOINHERIT}\n"
					  "    | {LOGIN | NOLOGIN}\n"
					  "    | {REPLICATION | NOREPLICATION}\n"
					  "    | {INDEPENDENT | NOINDEPENDENT}\n"
					  "    | {VCADMIN | NOVCADMIN}\n"
					  "    | {PERSISTENCE | NOPERSISTENCE}\n"
					  "    | CONNECTION LIMIT connlimit\n"
					  "    | VALID BEGIN 'timestamp'\n"
					  "    | VALID UNTIL 'timestamp'\n"
					  "    | RESOURCE POOL 'respool'\n"
					  "    | USER GROUP 'groupuser'\n"
					  "    | PERM SPACE 'spacelimit'\n"
					  "    | TEMP SPACE 'tmpspacelimit'\n"
					  "    | SPILL SPACE 'spillspacelimit'\n"
					  "    | NODE GROUP logic_group_name\n"
					  "    | IN ROLE role_name [, ...]\n"
					  "    | IN GROUP role_name [, ...]\n"
					  "    | ROLE role_name [, ...]\n"
					  "    | ADMIN role_name [, ...]\n"
					  "    | USER role_name [, ...]\n"
					  "    | SYSID uid\n"
					  "    | DEFAULT TABLESPACE tablespace_name\n"
					  "    | PROFILE DEFAULT\n"
					  "    | PROFILE profile_name\n"
					  "    | PGUSER");
}

void
sql_help_CREATE_INDEX(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "CREATE [ UNIQUE ] INDEX [ [schema_name.] index_name ] ON table_name [ USING method ]\n"
					  "    ({ { column_name | ( expression ) } [ COLLATE collation ] [ opclass ] [ ASC | DESC ] [ NULLS { FIRST | LAST } ] }[, ...] )\n"
					  "    [ WITH ( {storage_parameter = value} [, ... ] ) ]\n"
					  "    [ TABLESPACE tablespace_name ]\n"
					  "    [ WHERE predicate ];\n"
					  "CREATE [ UNIQUE ] INDEX [ [schema_name.] index_name ] ON table_name [ USING method ]\n"
					  "( {{ column_name | ( expression ) } [ COLLATE collation ] [ opclass ] [ ASC | DESC ] [ NULLS LAST ] }[, ...] )\n"
					  "[ LOCAL [ ( { PARTITION index_partition_name [ TABLESPACE index_partition_tablespace ] } [, ...] ) ] | GLOBAL ]\n"
					  "[ WITH ( { storage_parameter = value } [, ...] ) ]\n"
					  "[ TABLESPACE tablespace_name ];");
}

void
sql_help_CREATE_MASKING_POLICY(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "CREATE MASKING POLICY policy_name masking_clause [, ... ] [ policy_filter_clause ] [ ENABLE | DISABLE ];\n"
					  "\n"
					  "where masking_clause can be:\n"
					  "masking_function ON LABEL(label_name [, ... ])\n"
					  "\n"
					  "where masking_function can be:\n"
					  "{ maskall | randommasking | creditcardmasking | basicemailmasking | fullemailmasking | shufflemasking | alldigitsmasking }\n"
					  "\n"
					  "where policy_filter_clause can be:\n"
					  "FILTER ON { ( FILTER_TYPE ( filter_value [, ... ] ) ) [, ... ] }\n"
					  "\n"
					  "where FILTER_TYPE can be:\n"
					  "{ APP | ROLES | IP }");
}

void
sql_help_CREATE_MATERIALIZED_VIEW(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "CREATE [ INCREMENTAL ] MATERIALIZED VIEW %s\n"
					  "    [ (%s [, ...] ) ]\n"
					  "    [ TABLESPACE %s ]\n"
					  "    AS %s",
					  _("table_name"),
					  _("column_name"),
					  _("tablespace_name"),
					  _("query"));
}

void
sql_help_CREATE_NODE(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "CREATE NODE nodename WITH\n"
					  "  (\n"
					  "    [ TYPE = nodetype,]\n"
					  "    [ HOST = hostname,]\n"
					  "    [ PORT = portnum,]\n"
					  "    [ HOST1 = 'hostname',]\n"
					  "    [ PORT1 = portnum,]\n"
					  "    [ HOSTPRIMARY [ = boolean ],]\n"
					  "    [ PRIMARY [ = boolean ],]\n"
					  "    [ PREFERRED [ = boolean ],]\n"
					  "    [ SCTP_PORT = portnum,]\n"
					  "    [ CONTROL_PORT = portnum,]\n"
					  "    [ SCTP_PORT1 = portnum,]\n"
					  "    [ CONTROL_PORT1 = portnum, ]\n"
					  "    [ NODEIS_CENTRAL [= boolean], ]\n"
					  "    [ NODEIS_ACTIVE [= boolean] ]\n"
					  "  );");
}

void
sql_help_CREATE_NODE_GROUP(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "CREATE NODE GROUP %s\n"
					  "WITH ( %s [, ... ] )\n"
					  "[ BUCKETS [ ( bucketnumber [, ... ] ) ] ] \n"
					  "[ VCGROUP ] \n"
					  "[ DISTRIBUTE FROM src_nodegroup_name ];",
					  _("groupname"),
					  _("nodename"));
}

void
sql_help_CREATE_PROCEDURE(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "CREATE [ OR REPLACE ] PROCEDURE procedure_name\n"
					  "    [ ( {[ argmode ] [ argname ] argtype [ { DEFAULT | := | = } expression ]}[,...]) ]\n"
					  "   { IS | AS } plsql_body\n"
					  "/");
}

void
sql_help_CREATE_RESOURCE_LABEL(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "CREATE RESOURCE LABEL [ IF NOT EXISTS ] label_name ADD label_item_list[ , ... ];\n"
					  "\n"
					  "where label_item_list can be:\n"
					  "resource_type(resource_path[, ... ])\n"
					  "\n"
					  "where resource_type can be:\n"
					  "{ TABLE | COLUMN | SCHEMA | VIEW | FUNCTION }");
}

void
sql_help_CREATE_RESOURCE_POOL(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "CREATE RESOURCE POOL pool_name\n"
					  "    [WITH ({MEM_PERCENT=pct | CONTROL_GROUP=\"group_name\" | ACTIVE_STATEMENTS=stmt | MAX_DOP = dop | MEMORY_LIMIT='memory_size' | io_limits=io_limits | io_priority='priority' | nodegroup='nodegroup_name' | is_foreign = boolean }[, ... ])];");
}

void
sql_help_CREATE_ROLE(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "CREATE ROLE role_name [ [ WITH ] option [ ... ] ] [ ENCRYPTED | UNENCRYPTED ] { PASSWORD | IDENTIFIED BY } { 'password' [ EXPIRED ] | DISABLE };\n"
					  "\n"
					  "where option can be:\n"
					  "{SYSADMIN | NOSYSADMIN}\n"
					  "    | {MONADMIN | NOMONADMIN}\n"
					  "    | {OPRADMIN | NOOPRADMIN}\n"
					  "    | {POLADMIN | NOPOLADMIN}\n"
					  "    | {AUDITADMIN | NOAUDITADMIN}\n"
					  "    | {CREATEDB | NOCREATEDB}\n"
					  "    | {USEFT | NOUSEFT}\n"
					  "    | {CREATEROLE | NOCREATEROLE}\n"
					  "    | {INHERIT | NOINHERIT}\n"
					  "    | {LOGIN | NOLOGIN}\n"
					  "    | {REPLICATION | NOREPLICATION}\n"
					  "    | {INDEPENDENT | NOINDEPENDENT}\n"
					  "    | {VCADMIN | NOVCADMIN}\n"
					  "    | {PERSISTENCE | NOPERSISTENCE}\n"
					  "    | CONNECTION LIMIT connlimit\n"
					  "    | VALID BEGIN 'timestamp'\n"
					  "    | VALID UNTIL 'timestamp'\n"
					  "    | RESOURCE POOL 'respool'\n"
					  "    | USER GROUP 'groupuser'\n"
					  "    | PERM SPACE 'spacelimit'\n"
					  "    | TEMP SPACE 'tmpspacelimit'\n"
					  "    | SPILL SPACE 'spillspacelimit'\n"
					  "    | NODE GROUP logic_cluster_name\n"
					  "    | IN ROLE role_name [, ...]\n"
					  "    | IN GROUP role_name [, ...]\n"
					  "    | ROLE role_name [, ...]\n"
					  "    | ADMIN role_name [, ...]\n"
					  "    | USER role_name [, ...]\n"
					  "    | SYSID uid\n"
					  "    | DEFAULT TABLESPACE tablespace_name\n"
					  "    | PROFILE DEFAULT\n"
					  "    | PROFILE profile_name\n"
					  "    | PGUSER");
}

void
sql_help_CREATE_ROW_LEVEL_SECURITY_POLICY(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "CREATE [ ROW LEVEL SECURITY ] POLICY policy_name ON table_name\n"
					  "    [ AS { PERMISSIVE | RESTRICTIVE } ]\n"
					  "    [ FOR { ALL | SELECT | UPDATE | DELETE } ]\n"
					  "    [ TO { role_name | PUBLIC } [, ...] ]\n"
					  "    USING ( using_expression )");
}

void
sql_help_CREATE_SCHEMA(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "CREATE SCHEMA schema_name\n"
					  "    [ AUTHORIZATION user_name ] [ schema_element [ ... ] ];\n"
					  "CREATE SCHEMA AUTHORIZATION user_name [ schema_element [ ... ] ];");
}

void
sql_help_CREATE_SEQUENCE(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "CREATE SEQUENCE %s [ INCREMENT [ BY ] %s ]\n"
					  "    [ MINVALUE %s | NO MINVALUE | NOMINVALUE] [ MAXVALUE %s | NO MAXVALUE | NOMAXVALUE]\n"
					  "    [ START [ WITH ] %s ] [ CACHE %s ] [ [ NO ] CYCLE | NOCYCLE]\n"
					  "    [ OWNED BY { %s.%s | NONE } ];",
					  _("name"),
					  _("increment"),
					  _("minvalue"),
					  _("maxvalue"),
					  _("start"),
					  _("cache"),
					  _("table_name"),
					  _("column_name"));
}

void
sql_help_CREATE_SERVER(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "CREATE SERVER server_name \n"
					  "    FOREIGN DATA WRAPPER fdw_name\n"
					  "    OPTIONS ( { option_name ' value ' } [, ...] ) ;");
}

void
sql_help_CREATE_SYNONYM(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "CREATE [ OR REPLACE ] SYNONYM synonym_name\n"
					  "    FOR object_name;");
}

void
sql_help_CREATE_TABLE(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [ IF NOT EXISTS ] table_name \n"
					  "({ column_name data_type [ compress_mode ] [ COLLATE collation ] [ column_constraint [ ... ] ] [encrypted with ('column_encryption_key', 'encryption_type')]\n"
					  "    | table_constraint\n"
					  "    | LIKE source_table [ like_option [...] ] }\n"
					  "    [, ... ])\n"
					  "[ WITH ( {storage_parameter = value} [, ... ] ) ]\n"
					  "[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]\n"
					  "[ COMPRESS | NOCOMPRESS ]\n"
					  "[ TABLESPACE tablespace_name ]\n"
					  "[ DISTRIBUTE BY { REPLICATION | { HASH ( column_name [,...] ) | \n"
					  "  RANGE ( column_name [,...] ) range_distribution_rules | \n"
					  "  LIST ( column_name [,...] ) list_distribution_rules } } ]\n"
					  "[ TO { GROUP groupname | NODE ( nodename [, ... ] ) } ];\n"
					  "\n"
					  "where column_constraint can be:\n"
					  "[ CONSTRAINT constraint_name ]\n"
					  "{ NOT NULL |\n"
					  "  NULL |\n"
					  "  CHECK ( expression ) |\n"
					  "  DEFAULT default_expr |\n"
					  "  UNIQUE index_parameters |\n"
					  "  PRIMARY KEY index_parameters |\n"
					  "  REFERENCES reftable [ ( refcolumn ) ] [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ]\n"
					  "    [ ON DELETE action ] [ ON UPDATE action ] }\n"
					  "[ DEFERRABLE | NOT DEFERRABLE | INITIALLY DEFERRED | INITIALLY IMMEDIATE ]\n"
					  "where table_constraint can be:\n"
					  "[ CONSTRAINT constraint_name ]\n"
					  "{ CHECK ( expression ) |\n"
					  "  UNIQUE ( column_name [, ... ] ) index_parameters |\n"
					  "  PRIMARY KEY ( column_name [, ... ] ) index_parameters |\n"
					  "  PARTIAL CLUSTER KEY ( column_name [, ... ] ) |\n"
					  "  FOREIGN KEY ( column_name [, ... ] ) REFERENCES reftable [ ( refcolumn [, ... ] ) ]\n"
					  "    [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ] [ ON DELETE action ] [ ON UPDATE action ] }\n"
					  "[ DEFERRABLE | NOT DEFERRABLE | INITIALLY DEFERRED | INITIALLY IMMEDIATE ]\n"
					  "where compress_mode can be:\n"
					  "{ DELTA | PREFIX | DICTIONARY | NUMSTR | NOCOMPRESS }\n"
					  "where like_option can be:\n"
					  "{ INCLUDING | EXCLUDING } { DEFAULTS | CONSTRAINTS | INDEXES | STORAGE | COMMENTS | PARTITION | RELOPTIONS | DISTRIBUTION | ALL }\n"
					  "where index_parameters can be:\n"
					  "[ WITH ( {storage_parameter = value} [, ... ] ) ]\n"
					  "[ USING INDEX TABLESPACE tablespace_name ]\n"
					  "where range_distribution_rules can be:\n"
					  "[ ( SLICE name VALUES LESS THAN (expression | MAXVALUE [, ... ]) [DATANODE datanode_name]\n"
					  " [, ... ] ) | \n"
					  "  ( SLICE name START (expression) END (expression) EVERY (expression) [DATANODE datanode_name]\n"
					  " [, ... ] ) |\n"
					  "  SLICE REFERENCES table_name\n"
					  "] \n"
					  "where list_distribution_rules can be: \n"
					  "[ ( SLICE name VALUES (expression [, ... ]) [DATANODE datanode_name]\n"
					  " [, ... ] ) | \n"
					  "  ( SLICE name VALUES (DEFAULT) [DATANODE datanode_name] ) |\n"
					  "  SLICE REFERENCES table_name\n"
					  "]");
}

void
sql_help_CREATE_TABLE_AS(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "CREATE [ UNLOGGED ] TABLE table_name\n"
					  "    [ (column_name [, ...] ) ]\n"
					  "    [ WITH ( {storage_parameter = value} [, ... ] ) ]\n"
					  "    [ COMPRESS | NOCOMPRESS ]\n"
					  "    [ TABLESPACE tablespace_name ]\n"
					  "    [ DISTRIBUTE BY { REPLICATION | { [HASH ] ( column_name ) } } ]\n"
					  "    [ TO { GROUP groupname | NODE ( nodename [, ... ] ) } ]\n"
					  "    AS query\n"
					  "    [ WITH [ NO ] DATA ];");
}

void
sql_help_CREATE_TABLE_PARTITION(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "CREATE TABLE [ IF NOT EXISTS ] partition_table_name \n"
					  "( [\n"
					  "  { column_name data_type [ COLLATE collation ] [ column_constraint [ ... ] ]\n"
					  "    | table_constraint \n"
					  "    | LIKE source_table [ like_option [...] ] }\n"
					  "    [, ... ]\n"
					  "] )\n"
					  "[ WITH ( {storage_parameter = value} [, ... ] ) ]\n"
					  "[ COMPRESS | NOCOMPRESS ]\n"
					  "[ TABLESPACE tablespace_name ]\n"
					  "[ DISTRIBUTE BY { REPLICATION | { [ HASH ] ( column_name ) } } ]\n"
					  "[ TO { GROUP groupname | NODE ( nodename [, ... ] ) } ]\n"
					  "PARTITION BY { \n"
					  "	{VALUES (partition_key)} | \n"
					  "	{RANGE (partition_key) [ INTERVAL ('interval_expr') [ STORE IN ( tablespace_name [, ... ] ) ] ] ( partition_less_than_item [, ... ] )} |\n"
					  "	{RANGE (partition_key) [ INTERVAL ('interval_expr') [ STORE IN ( tablespace_name [, ... ] ) ] ] ( partition_start_end_item [, ... ] )}\n"
					  "} [ { ENABLE | DISABLE } ROW MOVEMENT ];\n"
					  "\n"
					  "where column_constraint can be:\n"
					  "[ CONSTRAINT constraint_name ]\n"
					  "{ NOT NULL |\n"
					  "  NULL |\n"
					  "  CHECK ( expression ) |\n"
					  "  DEFAULT default_expr |\n"
					  "  UNIQUE index_parameters |\n"
					  "  PRIMARY KEY index_parameters |\n"
					  "  REFERENCES reftable [ ( refcolumn ) ] [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ]\n"
					  "    [ ON DELETE action ] [ ON UPDATE action ] }\n"
					  "[ DEFERRABLE | NOT DEFERRABLE | INITIALLY DEFERRED | INITIALLY IMMEDIATE ]\n"
					  "where table_constraint can be:\n"
					  "[ CONSTRAINT constraint_name ]\n"
					  "{ CHECK ( expression ) |\n"
					  "  UNIQUE ( column_name [, ... ] ) index_parameters |\n"
					  "  PRIMARY KEY ( column_name [, ... ] ) index_parameters |\n"
					  "  FOREIGN KEY ( column_name [, ... ] ) REFERENCES reftable [ ( refcolumn [, ... ] ) ]\n"
					  "    [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ] [ ON DELETE action ] [ ON UPDATE action ] }\n"
					  "[ DEFERRABLE | NOT DEFERRABLE | INITIALLY DEFERRED | INITIALLY IMMEDIATE ]\n"
					  "where index_parameters can be:\n"
					  "[ WITH ( {storage_parameter = value} [, ... ] ) ]\n"
					  "[ USING INDEX TABLESPACE tablespace_name ]\n"
					  "where like_option can be:\n"
					  "{ INCLUDING | EXCLUDING } { DEFAULTS | CONSTRAINTS | INDEXES | STORAGE | COMMENTS | RELOPTIONS | DISTRIBUTION | ALL }\n"
					  "where partition_less_than_item can be:\n"
					  "PARTITION partition_name VALUES LESS THAN ( { partition_value | MAXVALUE } ) [TABLESPACE tablespace_name]\n"
					  "where partition_start_end_item can be:\n"
					  "PARTITION partition_name {\n"
					  "	{START(partition_value) END (partition_value) EVERY (interval_value)} |\n"
					  "	{START(partition_value) END ({partition_value | MAXVALUE})} |\n"
					  "	{START(partition_value)} |\n"
					  "	{END({partition_value | MAXVALUE})}\n"
					  "} [TABLESPACE tablespace_name]");
}

void
sql_help_CREATE_TABLESPACE(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "CREATE TABLESPACE tablespace_name\n"
					  "    [ OWNER user_name ]  [ RELATIVE ]  LOCATION 'directory' [ MAXSIZE 'space_size' ]\n"
					  "    [with_option_clause];\n"
					  "\n"
					  "where option_clause can be:\n"
					  "WITH ( filesystem= { 'systemtype '| \" systemtype \" | systemtype }\n"
					  " [ { , address = { ' ip:port [ , ... ] ' | \" ip:port [ , ... ] \"} } ]\n"
					  ", cfgpath = { 'path '| \" path \" } ,storepath = { 'rootpath '| \" rootpath \"} \n"
					  "[{, random_page_cost = { 'value '| \" value \" | value }}]\n"
					  "[{,seq_page_cost = { 'value '| \" value \" | value }}])");
}

void
sql_help_CREATE_TEXT_SEARCH_CONFIGURATION(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "CREATE TEXT SEARCH CONFIGURATION %s (\n"
					  "    PARSER = %s |\n"
					  "    COPY = %s\n"
					  ") [ WITH ( {configuration_option = value} [, ...] )];",
					  _("name"),
					  _("parser_name"),
					  _("source_config"));
}

void
sql_help_CREATE_TEXT_SEARCH_DICTIONARY(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "CREATE TEXT SEARCH DICTIONARY name \n"
					  "     ( TEMPLATE = template_name | COPY = source_config\n"
					  "     [, option = value [, ...] ] );");
}

void
sql_help_CREATE_TRIGGER(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "CREATE [ CONSTRAINT ] TRIGGER name { BEFORE | AFTER | INSTEAD OF } { event [ OR ... ] }\n"
					  "    ON table_name\n"
					  "    [ FROM referenced_table_name ]\n"
					  "    { NOT DEFERRABLE | [ DEFERRABLE ] { INITIALLY IMMEDIATE | INITIALLY DEFERRED } }\n"
					  "    [ FOR [ EACH ] { ROW | STATEMENT } ]\n"
					  "    [ WHEN ( condition ) ]\n"
					  "    EXECUTE PROCEDURE function_name ( arguments )\n"
					  "\n"
					  "where event can be one of:\n"
					  "\n"
					  "    INSERT\n"
					  "    UPDATE [ OF column_name [, ... ] ]\n"
					  "    DELETE\n"
					  "    TRUNCATE");
}

void
sql_help_CREATE_TYPE(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "CREATE TYPE %s AS\n"
					  "    ( [ %s %s [ COLLATE %s ] [, ... ] ] )\n"
					  "\n"
					  "CREATE TYPE %s AS ENUM\n"
					  "    ( [ '%s' [, ... ] ] )\n"
					  "\n"
					  "CREATE TYPE %s (\n"
					  "    INPUT = %s,\n"
					  "    OUTPUT = %s\n"
					  "    [ , RECEIVE = %s ]\n"
					  "    [ , SEND = %s ]\n"
					  "    [ , TYPMOD_IN = %s ]\n"
					  "    [ , TYPMOD_OUT = %s ]\n"
					  "    [ , ANALYZE = %s ]\n"
					  "    [ , INTERNALLENGTH = { %s | VARIABLE } ]\n"
					  "    [ , PASSEDBYVALUE ]\n"
					  "    [ , ALIGNMENT = %s ]\n"
					  "    [ , STORAGE = %s ]\n"
					  "    [ , LIKE = %s ]\n"
					  "    [ , CATEGORY = %s ]\n"
					  "    [ , PREFERRED = %s ]\n"
					  "    [ , DEFAULT = %s ]\n"
					  "    [ , ELEMENT = %s ]\n"
					  "    [ , DELIMITER = %s ]\n"
					  "    [ , COLLATABLE = %s ]\n"
					  ")\n"
					  "\n"
					  "CREATE TYPE %s",
					  _("name"),
					  _("attribute_name"),
					  _("data_type"),
					  _("collation"),
					  _("name"),
					  _("label"),
					  _("name"),
					  _("input_function"),
					  _("output_function"),
					  _("receive_function"),
					  _("send_function"),
					  _("type_modifier_input_function"),
					  _("type_modifier_output_function"),
					  _("analyze_function"),
					  _("internallength"),
					  _("alignment"),
					  _("storage"),
					  _("like_type"),
					  _("category"),
					  _("preferred"),
					  _("default"),
					  _("element"),
					  _("delimiter"),
					  _("collatable"),
					  _("name"));
}

void
sql_help_CREATE_USER(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "CREATE USER user_name [ [ WITH ] option [ ... ] ] [ ENCRYPTED | UNENCRYPTED ] { PASSWORD | IDENTIFIED BY } { 'password' [ EXPIRED ] | DISABLE };\n"
					  "\n"
					  "where option can be:\n"
					  "{SYSADMIN | NOSYSADMIN}\n"
					  "    | {MONADMIN | NOMONADMIN}\n"
					  "    | {OPRADMIN | NOOPRADMIN}\n"
					  "    | {POLADMIN | NOPOLADMIN}\n"
					  "    | {AUDITADMIN | NOAUDITADMIN}\n"
					  "    | {CREATEDB | NOCREATEDB}\n"
					  "    | {USEFT | NOUSEFT}\n"
					  "    | {CREATEROLE | NOCREATEROLE}\n"
					  "    | {INHERIT | NOINHERIT}\n"
					  "    | {LOGIN | NOLOGIN}\n"
					  "    | {REPLICATION | NOREPLICATION}\n"
					  "    | {INDEPENDENT | NOINDEPENDENT}\n"
					  "    | {VCADMIN | NOVCADMIN}\n"
					  "    | {PERSISTENCE | NOPERSISTENCE}\n"
					  "    | CONNECTION LIMIT connlimit\n"
					  "    | VALID BEGIN 'timestamp'\n"
					  "    | VALID UNTIL 'timestamp'\n"
					  "    | RESOURCE POOL 'respool'\n"
					  "    | USER GROUP 'groupuser'\n"
					  "    | PERM SPACE 'spacelimit'\n"
					  "    | TEMP SPACE 'tmpspacelimit'\n"
					  "    | SPILL SPACE 'spillspacelimit'\n"
					  "    | NODE GROUP logic_cluster_name\n"
					  "    | IN ROLE role_name [, ...]\n"
					  "    | IN GROUP role_name [, ...]\n"
					  "    | ROLE role_name [, ...]\n"
					  "    | ADMIN role_name [, ...]\n"
					  "    | USER role_name [, ...]\n"
					  "    | SYSID uid\n"
					  "    | DEFAULT TABLESPACE tablespace_name\n"
					  "    | PROFILE DEFAULT\n"
					  "    | PROFILE profile_name\n"
					  "    | PGUSER");
}

void
sql_help_CREATE_VIEW(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "CREATE [ OR REPLACE ] [ TEMP | TEMPORARY ] VIEW view_name [ ( column_name [, ...] ) ]\n"
					  "    [ WITH ( {view_option_name [= view_option_value]} [, ... ] ) ]\n"
					  "    AS query;");
}

void
sql_help_CREATE_WEAK_PASSWORD_DICTIONARY(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "CREATE WEAK PASSWORD DICTIONARY  \n"
					  "     [WITH VALUES] ( {'weak_password'} [, ...] );");
}

void
sql_help_CREATE_WORKLOAD_GROUP(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "CREATE WORKLOAD GROUP wg_name\n"
					  "     [ USING RESOURCE POOL pool_name [ WITH ( ACT_STATEMENTS = counts) ] ];");
}

void
sql_help_CURSOR(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "CURSOR cursor_name\n"
					  "    [ BINARY ] [ INSENSITIVE ] [ [ NO ] SCROLL ]\n"
					  "    FOR query ;");
}

void
sql_help_DEALLOCATE(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "DEALLOCATE [ PREPARE ] { name | ALL };");
}

void
sql_help_DECLARE(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "1. declare a cursor:\n"
					  "DECLARE cursor_name [ BINARY ] [ NO SCROLL ]\n"
					  "    CURSOR [ { WITH | WITHOUT } HOLD ] FOR query ;\n"
					  "\n"
					  "2. start an anonymous block:\n"
					  "[DECLARE [declare_statements]] \n"
					  "BEGIN\n"
					  "execution_statements\n"
					  "END;\n"
					  "/");
}

void
sql_help_DELETE(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "[ WITH [ RECURSIVE ] with_query [, ...] ]\n"
					  "DELETE FROM [ ONLY ] table_name [ * ] [ [ AS ] alias ]\n"
					  "    [ USING using_list ]\n"
					  "    [ WHERE condition | WHERE CURRENT OF cursor_name ] [ LIMIT row_count ]\n"
					  "    [ RETURNING { * | { output_expr [ [ AS ] output_name ] } [, ...] } ];");
}

void
sql_help_DO(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "DO [ LANGUAGE lang_name ] code;");
}

void
sql_help_DROP_APP_WORKLOAD_GROUP(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "DROP APP WORKLOAD GROUP MAPPING [IF EXISTS] app_name");
}

void
sql_help_DROP_APP_WORKLOAD_GROUP_MAPPING(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "DROP APP WORKLOAD GROUP MAPPING [ IF EXISTS ] app_name;");
}

void
sql_help_DROP_AUDIT_POLICY(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "DROP AUDIT POLICY [IF EXISTS] policy_name;");
}

void
sql_help_DROP_CLIENT_MASTER_KEY(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "DROP CLIENT MASTER KEY [ IF EXISTS ] client_master_key_name [, ...];");
}

void
sql_help_DROP_COLUMN_ENCRYPTION_KEY(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "DROP COLUMN ENCRYPTION KEY [ IF EXISTS ] client_column_key_name [, ...];");
}

void
sql_help_DROP_DATA_SOURCE(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "DROP DATA SOURCE [IF EXISTS] src_name [CASCADE | RESTRICT];");
}

void
sql_help_DROP_DATABASE(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "DROP DATABASE [ IF EXISTS ] database_name;");
}

void
sql_help_DROP_DIRECTORY(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "DROP DIRECTORY [ IF EXISTS ] directory_name;");
}

void
sql_help_DROP_EXTENSION(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "DROP EXTENSION [ IF EXISTS ] %s [, ...] [ CASCADE | RESTRICT ];",
					  _("name"));
}

void
sql_help_DROP_FOREIGN_TABLE(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "DROP FOREIGN TABLE [ IF EXISTS ] \n"
					  "table_name [, ...] [ CASCADE | RESTRICT ];");
}

void
sql_help_DROP_FUNCTION(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "DROP FUNCTION [ IF EXISTS ] function_name [ ( [ {[ argmode ] [ argname ] argtype} [, ...] ] ) [ CASCADE | RESTRICT ] ];");
}

void
sql_help_DROP_GROUP(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "DROP GROUP [ IF EXISTS ] group_name [, ...];");
}

void
sql_help_DROP_INDEX(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "DROP INDEX [ CONCURRENTLY ] [ IF EXISTS ] \n"
					  "index_name [, ...] [ CASCADE | RESTRICT ];");
}

void
sql_help_DROP_MASKING_POLICY(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "DROP MASKING POLICY [IF EXISTS] policy_name;");
}

void
sql_help_DROP_MATERIALIZED_VIEW(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "DROP MATERIALIZED VIEW [ IF EXISTS ] %s [, ...] [ CASCADE | RESTRICT ]",
					  _("name"));
}

void
sql_help_DROP_NODE(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "DROP NODE nodename;");
}

void
sql_help_DROP_NODE_GROUP(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "DROP NODE GROUP %s\n"
					  "    [ DISTRIBUTE FROM src_nodegroup_name ]\n"
					  "    [ TO ELASTIC GROUP ]",
					  _("groupname;"));
}

void
sql_help_DROP_OWNED(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "DROP OWNED BY name [, ...] [ CASCADE | RESTRICT ];");
}

void
sql_help_DROP_PROCEDURE(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "DROP PROCEDURE [ IF EXISTS ] procedure_name;");
}

void
sql_help_DROP_RESOURCE_LABEL(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "DROP RESOURCE LABEL [ IF EXISTS ] policy_name[, ... ];");
}

void
sql_help_DROP_RESOURCE_POOL(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "DROP RESOURCE POOL [ IF EXISTS ] pool_name;");
}

void
sql_help_DROP_ROLE(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "DROP ROLE [ IF EXISTS ] role_name [, ...];");
}

void
sql_help_DROP_ROW_LEVEL_SECURITY_POLICY(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "DROP [ ROW LEVEL SECURITY ] POLICY [ IF EXISTS ] policy_name ON table_name [ CASCADE | RESTRICT ]");
}

void
sql_help_DROP_SCHEMA(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "DROP SCHEMA [ IF EXISTS ] schema_name [, ...] [ CASCADE | RESTRICT ];");
}

void
sql_help_DROP_SEQUENCE(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "DROP SEQUENCE [ IF EXISTS ] {[schema.]sequence_name} [, ...] [ CASCADE | RESTRICT ];");
}

void
sql_help_DROP_SERVER(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "DROP SERVER [ IF EXISTS ] server_name [ { CASCADE | RESTRICT } ] ;");
}

void
sql_help_DROP_SYNONYM(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "DROP SYNONYM [ IF EXISTS ] synonym_name [ CASCADE | RESTRICT ];");
}

void
sql_help_DROP_TABLE(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "DROP TABLE [ IF EXISTS ] \n"
					  "{[schema.]table_name} [, ...] [ CASCADE | RESTRICT ];");
}

void
sql_help_DROP_TABLESPACE(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "DROP TABLESPACE [ IF EXISTS ] tablespace_name;");
}

void
sql_help_DROP_TEXT_SEARCH_CONFIGURATION(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "DROP TEXT SEARCH CONFIGURATION [ IF EXISTS ] %s [ CASCADE | RESTRICT ]",
					  _("name"));
}

void
sql_help_DROP_TEXT_SEARCH_DICTIONARY(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "DROP TEXT SEARCH DICTIONARY [ IF EXISTS ] name [ CASCADE | RESTRICT ];");
}

void
sql_help_DROP_TRIGGER(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "DROP TRIGGER [ IF EXISTS ] name ON table_name [ CASCADE | RESTRICT ]");
}

void
sql_help_DROP_TYPE(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "DROP TYPE [ IF EXISTS ] %s [, ...] [ CASCADE | RESTRICT ]",
					  _("name"));
}

void
sql_help_DROP_USER(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "DROP USER [ IF EXISTS ] user_name [, ...] [ CASCADE | RESTRICT ];");
}

void
sql_help_DROP_VIEW(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "DROP VIEW [ IF EXISTS ] view_name [, ...] [ CASCADE | RESTRICT ];");
}

void
sql_help_DROP_WEAK_PASSWORD_DICTIONARY(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "DROP WEAK PASSWORD DICTIONARY;");
}

void
sql_help_DROP_WORKLOAD_GROUP(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "DROP WORKLOAD GROUP  [ IF EXISTS ] wg_name;");
}

void
sql_help_END(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "END [ WORK | TRANSACTION ]");
}

void
sql_help_EXECUTE(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "EXECUTE name [ ( parameter [, ...] ) ];");
}

void
sql_help_EXECUTE_DIRECT(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "EXECUTE DIRECT ON ( nodename [, ... ] ) query;\n"
					  "EXECUTE DIRECT ON { COORDINATORS | DATANODES | ALL } query;");
}

void
sql_help_EXPLAIN(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "EXPLAIN [ (  option  [, ...] )  ] statement;\n"
					  "EXPLAIN  { [  { ANALYZE  | ANALYSE  }  ] [ VERBOSE  ]  | PERFORMANCE  } statement;\n"
					  "\n"
					  "where option can be:\n"
					  "ANALYZE [ boolean ] |\n"
					  "    ANALYSE [ boolean ] |\n"
					  "    VERBOSE [ boolean ] |\n"
					  "    COSTS [ boolean ] |\n"
					  "    CPU [ boolean ] |\n"
					  "    DETAIL [ boolean ] |\n"
					  "    NODES [ boolean ] |\n"
					  "    NUM_NODES [ boolean ] |\n"
					  "    BUFFERS [ boolean ] |\n"
					  "    TIMING [ boolean ] |\n"
					  "    PLAN [ boolean ] |\n"
					  "    FORMAT { TEXT | XML | JSON | YAML }");
}

void
sql_help_FETCH(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "FETCH [ direction { FROM | IN } ] cursor_name;\n"
					  "\n"
					  "where direction can be:\n"
					  "NEXT\n"
					  "   | PRIOR\n"
					  "   | FIRST\n"
					  "   | LAST\n"
					  "   | ABSOLUTE count\n"
					  "   | RELATIVE count\n"
					  "   | count\n"
					  "   | ALL\n"
					  "   | FORWARD\n"
					  "   | FORWARD count\n"
					  "   | FORWARD ALL\n"
					  "   | BACKWARD\n"
					  "   | BACKWARD count\n"
					  "   | BACKWARD ALL");
}

void
sql_help_GRANT(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "GRANT { { SELECT | INSERT | UPDATE | DELETE | TRUNCATE | REFERENCES |\n"
					  "    ALTER | DROP | COMMENT | INDEX | VACUUM } [, ...] | ALL [ PRIVILEGES ] }\n"
					  "    ON { [ TABLE ] table_name [, ...]\n"
					  "         | ALL TABLES IN SCHEMA schema_name [, ...] }\n"
					  "    TO { [ GROUP ] role_name | PUBLIC } [, ...] \n"
					  "    [ WITH GRANT OPTION ];\n"
					  "GRANT { {{ SELECT | INSERT | UPDATE | REFERENCES | COMMENT } ( column_name [, ...] )}\n"
					  "    [, ...] | ALL [ PRIVILEGES ] ( column_name [, ...] ) }\n"
					  "    ON [ TABLE ] table_name [, ...]\n"
					  "    TO { [ GROUP ] role_name | PUBLIC } [, ...]\n"
					  "    [ WITH GRANT OPTION ];\n"
					  "GRANT { { CREATE | CONNECT | TEMPORARY | TEMP | ALTER | DROP | COMMENT }\n"
					  "    [, ...] | ALL [ PRIVILEGES ] }\n"
					  "    ON DATABASE database_name [, ...]\n"
					  "    TO { [ GROUP ] role_name | PUBLIC } [, ...]\n"
					  "    [ WITH GRANT OPTION ];\n"
					  "GRANT { USAGE | ALL [ PRIVILEGES ] }\n"
					  "    ON DOMAIN domain_name [, ...]\n"
					  "    TO { [ GROUP ] role_name | PUBLIC } [, ...]\n"
					  "    [ WITH GRANT OPTION ];\n"
					  "GRANT { USAGE | ALL [ PRIVILEGES ] }\n"
					  "    ON FOREIGN DATA WRAPPER fdw_name [, ...]\n"
					  "    TO { [ GROUP ] role_name | PUBLIC } [, ...]\n"
					  "    [ WITH GRANT OPTION ];\n"
					  "GRANT { { USAGE | ALTER | DROP | COMMENT } [, ...] | ALL [ PRIVILEGES ] }\n"
					  "    ON FOREIGN SERVER server_name [, ...]\n"
					  "    TO { [ GROUP ] role_name | PUBLIC } [, ...]\n"
					  "    [ WITH GRANT OPTION ];\n"
					  "GRANT { { EXECUTE | ALTER | DROP | COMMENT } [, ...] | ALL [ PRIVILEGES ] }\n"
					  "    ON { FUNCTION {function_name ( [ {[ argmode ] [ arg_name ] arg_type} [, ...] ] )} [, ...]\n"
					  "         | ALL FUNCTIONS IN SCHEMA schema_name [, ...] }\n"
					  "    TO { [ GROUP ] role_name | PUBLIC } [, ...]\n"
					  "    [ WITH GRANT OPTION ];\n"
					  "GRANT { USAGE | ALL [ PRIVILEGES ] }\n"
					  "    ON LANGUAGE lang_name [, ...]\n"
					  "    TO { [ GROUP ] role_name | PUBLIC } [, ...]\n"
					  "    [ WITH GRANT OPTION ];\n"
					  "GRANT { { SELECT | UPDATE } [, ...] | ALL [ PRIVILEGES ] }\n"
					  "    ON LARGE OBJECT loid [, ...]\n"
					  "    TO { [ GROUP ] role_name | PUBLIC } [, ...]\n"
					  "    [ WITH GRANT OPTION ];\n"
					  "GRANT { { CREATE | USAGE | ALTER | DROP | COMMENT } [, ...] | ALL [ PRIVILEGES ] }\n"
					  "    ON SCHEMA schema_name [, ...]\n"
					  "    TO { [ GROUP ] role_name | PUBLIC } [, ...]\n"
					  "    [ WITH GRANT OPTION ];\n"
					  "GRANT { { CREATE | ALTER | DROP | COMMENT } [, ...] | ALL [ PRIVILEGES ] }\n"
					  "    ON TABLESPACE tablespace_name [, ...]\n"
					  "    TO { [ GROUP ] role_name | PUBLIC } [, ...]\n"
					  "    [ WITH GRANT OPTION ];\n"
					  "GRANT { { USAGE | ALTER | DROP | COMMENT } [, ...] | ALL [ PRIVILEGES ] }\n"
					  "    ON TYPE type_name [, ...]\n"
					  "    TO { [ GROUP ] role_name | PUBLIC } [, ...]\n"
					  "    [ WITH GRANT OPTION ];\n"
					  "GRANT { { CREATE | USAGE | COMPUTE | ALTER | DROP } [, ...] | ALL [ PRIVILEGES ] }\n"
					  "    ON NODE GROUP group_name [, ...]\n"
					  "    TO { [ GROUP ] role_name | PUBLIC } [, ...]\n"
					  "    [ WITH GRANT OPTION ];\n"
					  "GRANT role_name [, ...]\n"
					  "   TO role_name [, ...]\n"
					  "   [ WITH ADMIN OPTION ];\n"
					  "GRANT ALL { PRIVILEGES | PRIVILEGE }\n"
					  "   TO role_name;\n"
					  "GRANT {USAGE | ALL [PRIVILEGES]}\n"
					  "   ON DATA SOURCE src_name [, ...]\n"
					  "   TO {[GROUP] role_name | PUBLIC]} [, ...] [WITH GRANT OPTION];");
}

void
sql_help_INSERT(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "[ WITH [ RECURSIVE ] with_query [, ...] ]\n"
					  "INSERT INTO table_name [ ( column_name [, ...] ) ]\n"
					  "    { DEFAULT VALUES | VALUES {( { expression | DEFAULT } [, ...] ) }[, ...] | query }\n"
					  "    [ ON DUPLICATE KEY UPDATE { NOTHING | { column_name = { expression | DEFAULT } } [, ...] } ]\n"
					  "    [ RETURNING {* | {output_expression [ [ AS ] output_name ] }[, ...]} ];");
}

void
sql_help_LOCK(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "LOCK [ TABLE ] {[ ONLY ] name [, ...]| {name [ * ]} [, ...]}\n"
					  "    [ IN {ACCESS SHARE | ROW SHARE | ROW EXCLUSIVE | SHARE UPDATE EXCLUSIVE | SHARE | SHARE ROW EXCLUSIVE | EXCLUSIVE | ACCESS EXCLUSIVE} MODE ]\n"
					  "    [ NOWAIT ];");
}

void
sql_help_MERGE(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "MERGE INTO table_name [ [ AS ] alias ]\n"
					  "USING { { table_name | view_name } | subquery } [ [ AS ] alias ]\n"
					  "ON ( condition )\n"
					  "[\n"
					  "  WHEN MATCHED THEN\n"
					  "  UPDATE SET { column_name = { expression | DEFAULT } |\n"
					  "          ( column_name [, ...] ) = ( { expression | DEFAULT } [, ...] ) } [, ...]\n"
					  "  [ WHERE condition ]\n"
					  "]\n"
					  "[\n"
					  "  WHEN NOT MATCHED THEN\n"
					  "  INSERT { DEFAULT VALUES |\n"
					  "  [ ( column_name [, ...] ) ] VALUES ( { expression | DEFAULT } [, ...] ) [, ...] [ WHERE condition ] }\n"
					  "];");
}

void
sql_help_MOVE(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "MOVE [ direction [ FROM | IN ] ] cursor_name;\n"
					  "\n"
					  "where direction can be:\n"
					  "NEXT\n"
					  "   | PRIOR\n"
					  "   | FIRST\n"
					  "   | LAST\n"
					  "   | ABSOLUTE count\n"
					  "   | RELATIVE count\n"
					  "   | count\n"
					  "   | ALL\n"
					  "   | FORWARD\n"
					  "   | FORWARD count\n"
					  "   | FORWARD ALL\n"
					  "   | BACKWARD\n"
					  "   | BACKWARD count\n"
					  "   | BACKWARD ALL");
}

void
sql_help_PREPARE(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "PREPARE name [ ( data_type [, ...] ) ] AS statement;");
}

void
sql_help_PREPARE_TRANSACTION(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "PREPARE TRANSACTION transaction_id;");
}

void
sql_help_REASSIGN_OWNED(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "REASSIGN OWNED BY old_role [, ...] TO new_role;");
}

void
sql_help_REFRESH_MATERIALIZED_VIEW(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "REFRESH [ INCREMENTAL ] MATERIALIZED VIEW %s",
					  _("name"));
}

void
sql_help_REINDEX(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "REINDEX { INDEX | [INTERNAL] TABLE | DATABASE | SYSTEM } name [ FORCE ];\n"
					  "REINDEX  { INDEX | [INTERNAL] TABLE  } name\n"
					  "    PARTITION partition_name [ FORCE  ];");
}

void
sql_help_RESET(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "RESET {configuration_parameter | CURRENT_SCHEMA | TIME ZONE | TRANSACTION ISOLATION LEVEL | SESSION AUTHORIZATION | ALL };");
}

void
sql_help_REVOKE(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "REVOKE ALL { PRIVILEGES | PRIVILEGE } FROM role_name;\n"
					  "REVOKE [ GRANT OPTION FOR ]\n"
					  "    { { SELECT | INSERT | UPDATE | DELETE | TRUNCATE | REFERENCES |\n"
					  "    ALTER | DROP | COMMENT | INDEX | VACUUM } [, ...] | ALL [ PRIVILEGES ] }\n"
					  "    ON { [ TABLE ] table_name [, ...]\n"
					  "         | ALL TABLES IN SCHEMA schema_name [, ...] }\n"
					  "    FROM { [ GROUP ] role_name | PUBLIC } [, ...]\n"
					  "    [ CASCADE | RESTRICT ];\n"
					  "REVOKE [ GRANT OPTION FOR ]\n"
					  "    { {{ SELECT | INSERT | UPDATE | REFERENCES | COMMENT } ( column_name [, ...] )}\n"
					  "    [, ...] | ALL [ PRIVILEGES ] ( column_name [, ...] ) }\n"
					  "    ON [ TABLE ] table_name [, ...]\n"
					  "    FROM { [ GROUP ] role_name | PUBLIC } [, ...]\n"
					  "    [ CASCADE | RESTRICT ];\n"
					  "REVOKE [ GRANT OPTION FOR ]\n"
					  "    { { CREATE | CONNECT | TEMPORARY | TEMP | ALTER | DROP | COMMENT} [, ...] | ALL [ PRIVILEGES ] }\n"
					  "    ON DATABASE database_name [, ...]\n"
					  "    FROM { [ GROUP ] role_name | PUBLIC } [, ...]\n"
					  "    [ CASCADE | RESTRICT ];\n"
					  "REVOKE [ GRANT OPTION FOR ]\n"
					  "    { USAGE | ALL [ PRIVILEGES ] }\n"
					  "    ON DOMAIN domain_name [, ...]\n"
					  "    FROM { [ GROUP ] role_name | PUBLIC } [, ...]\n"
					  "    [ CASCADE | RESTRICT ];\n"
					  "REVOKE [ GRANT OPTION FOR ]\n"
					  "    { READ | WRITE | EXECUTE | ALL [ PRIVILEGES ] }\n"
					  "    ON DIRECTORY directory_name [, ...]\n"
					  "    FROM { [ GROUP ] role_name | PUBLIC } [, ...]\n"
					  "    [ CASCADE | RESTRICT ];\n"
					  "REVOKE [ GRANT OPTION FOR ]\n"
					  "    { USAGE | ALL [ PRIVILEGES ] }\n"
					  "    ON FOREIGN DATA WRAPPER fdw_name [, ...]\n"
					  "    FROM { [ GROUP ] role_name | PUBLIC } [, ...]\n"
					  "    [ CASCADE | RESTRICT ];\n"
					  "REVOKE [ GRANT OPTION FOR ]\n"
					  "    { { USAGE | ALTER | DROP | COMMENT } [, ...] | ALL [ PRIVILEGES ] }\n"
					  "    ON FOREIGN SERVER server_name [, ...]\n"
					  "    FROM { [ GROUP ] role_name | PUBLIC } [, ...]\n"
					  "    [ CASCADE | RESTRICT ];\n"
					  "REVOKE [ GRANT OPTION FOR ]\n"
					  "    { { EXECUTE | ALTER | DROP | COMMENT } [, ...] | ALL [ PRIVILEGES ] }\n"
					  "    ON { FUNCTION {function_name ( [ {[ argmode ] [ arg_name ] arg_type} [, ...] ] )} [, ...]\n"
					  "         | ALL FUNCTIONS IN SCHEMA schema_name [, ...] }\n"
					  "    FROM { [ GROUP ] role_name | PUBLIC } [, ...]\n"
					  "    [ CASCADE | RESTRICT ];\n"
					  "REVOKE [ GRANT OPTION FOR ]\n"
					  "    { USAGE | ALL [ PRIVILEGES ] }\n"
					  "    ON LANGUAGE lang_name [, ...]\n"
					  "    FROM { [ GROUP ] role_name | PUBLIC } [, ...]\n"
					  "    [ CASCADE | RESTRICT ];\n"
					  "REVOKE [ GRANT OPTION FOR ]\n"
					  "    { { SELECT | UPDATE } [, ...] | ALL [ PRIVILEGES ] }\n"
					  "    ON LARGE OBJECT loid [, ...]\n"
					  "    FROM { [ GROUP ] role_name | PUBLIC } [, ...]\n"
					  "    [ CASCADE | RESTRICT ];\n"
					  "REVOKE [ GRANT OPTION FOR ]\n"
					  "    { { CREATE | USAGE | ALTER | DROP | COMMENT } [, ...] | ALL [ PRIVILEGES ] }\n"
					  "    ON SCHEMA schema_name [, ...]\n"
					  "    FROM { [ GROUP ] role_name | PUBLIC } [, ...]\n"
					  "    [ CASCADE | RESTRICT ];\n"
					  "REVOKE [ GRANT OPTION FOR ]\n"
					  "    { { CREATE | ALTER | DROP | COMMENT } [, ...] | ALL [ PRIVILEGES ] }\n"
					  "    ON TABLESPACE tablespace_name [, ...]\n"
					  "    FROM { [ GROUP ] role_name | PUBLIC } [, ...]\n"
					  "    [ CASCADE | RESTRICT ];\n"
					  "REVOKE [ GRANT OPTION FOR ]\n"
					  "    { { USAGE | ALTER | DROP | COMMENT } [, ...] | ALL [ PRIVILEGES ] }\n"
					  "    ON TYPE type_name [, ...]\n"
					  "    FROM { [ GROUP ] role_name | PUBLIC } [, ...]\n"
					  "    [ CASCADE | RESTRICT ];\n"
					  "REVOKE [ GRANT OPTION FOR ]\n"
					  "    { {CREATE | USAGE | COMPUTE | ALTER | DROP } [, ...] | ALL [ PRIVILEGES ] }\n"
					  "    ON NODE GROUP group_name [, ...]\n"
					  "    FROM { [ GROUP ] role_name | PUBLIC } [, ...]\n"
					  "    [ CASCADE | RESTRICT ];\n"
					  "REVOKE [ ADMIN OPTION FOR ]\n"
					  "    role_name [, ...] FROM role_name [, ...]\n"
					  "    [ CASCADE | RESTRICT ];\n"
					  "REVOKE {USAGE | ALL [PRIVILEGES]}\n"
					  "    ON DATA SOURCE src_name [, ...]\n"
					  "    FROM {[GROUP] role_name | PUBLIC} [, ...];");
}

void
sql_help_ROLLBACK(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "ROLLBACK [ WORK | TRANSACTION ];");
}

void
sql_help_ROLLBACK_PREPARED(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "ROLLBACK PREPARED transaction_id;");
}

void
sql_help_SELECT(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "[ WITH [ RECURSIVE ] with_query [, ...] ]\n"
					  "SELECT [/*+ plan_hint */] [ ALL | DISTINCT [ ON ( expression [, ...] ) ] ]\n"
					  "    { * | {expression [ [ AS ] output_name ]} [, ...] }\n"
					  "    [ FROM from_item [, ...] ]\n"
					  "    [ WHERE condition ]\n"
					  "    [ GROUP BY grouping_element [, ...] ]\n"
					  "    [ HAVING condition [, ...] ]\n"
					  "    [ WINDOW {window_name AS ( window_definition )} [, ...] ]\n"
					  "    [ { UNION | INTERSECT | EXCEPT | MINUS } [ ALL | DISTINCT ] select ]\n"
					  "    [ ORDER BY {expression [ [ ASC | DESC | USING operator ] | nlssort_expression_clause ] [ NULLS { FIRST | LAST } ]} [, ...] ]\n"
					  "    [ LIMIT { [offset,] count | ALL } ] \n"
					  "    [ OFFSET start [ ROW | ROWS ] ]\n"
					  "    [ FETCH { FIRST | NEXT } [ count ] { ROW | ROWS } ONLY ]\n"
					  "    [ {FOR { UPDATE | SHARE } [ OF table_name [, ...] ] [ NOWAIT ]} [...] ];\n"
					  "TABLE { ONLY {(table_name)| table_name} | table_name [ * ]};\n"
					  "\n"
					  "where from_item can be:\n"
					  "[ ONLY ] table_name [ * ] [ partition_clause ] [ [ AS ] alias [ ( column_alias [, ...] ) ] ]\n"
					  "[ TABLESAMPLE sampling_method ( argument [, ...] ) [ REPEATABLE ( seed ) ] ]\n"
					  "|( select ) [ AS ] alias [ ( column_alias [, ...] ) ]\n"
					  "|with_query_name [ [ AS ] alias [ ( column_alias [, ...] ) ] ]\n"
					  "|function_name ( [ argument [, ...] ] ) [ AS ] alias [ ( column_alias [, ...] | column_definition [, ...] ) ]\n"
					  "|function_name ( [ argument [, ...] ] ) AS ( column_definition [, ...] )\n"
					  "|from_item [ NATURAL ] join_type from_item [ ON join_condition | USING ( join_column [, ...] ) ]\n"
					  "where grouping_element can be:\n"
					  "() \n"
					  "|expression \n"
					  "|( expression [, ...] ) \n"
					  "|ROLLUP ( { expression | ( expression [, ...] ) } [, ...] )\n"
					  "|CUBE ( { expression | ( expression [, ...] ) } [, ...] )\n"
					  "|GROUPING SETS ( grouping_element [, ...] )\n"
					  "where with_query can be:\n"
					  "with_query_name [ ( column_name [, ...] ) ] AS ( {select | values | insert | update | delete} )\n"
					  "where partition_clause can be:\n"
					  "PARTITION { ( partition_name ) | FOR (  partition_value [, ...] ) }\n"
					  "where nlssort_expression_clause can be:\n"
					  "NLSSORT ( column_name, ' NLS_SORT = { SCHINESE_PINYIN_M | generic_m_ci } ' )");
}

void
sql_help_SELECT_INTO(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "[ WITH [ RECURSIVE ] with_query [, ...] ]\n"
					  "SELECT [ ALL | DISTINCT [ ON ( expression [, ...] ) ] ]\n"
					  "    { * | {expression [ [ AS ] output_name ]} [, ...] }\n"
					  "    INTO [ UNLOGGED ] [ TABLE ] new_table\n"
					  "    [ FROM from_item [, ...] ]\n"
					  "    [ WHERE condition ]\n"
					  "    [ GROUP BY expression [, ...] ]\n"
					  "    [ HAVING condition [, ...] ]\n"
					  "    [ WINDOW {window_name AS ( window_definition )} [, ...] ]\n"
					  "    [ { UNION | INTERSECT | EXCEPT | MINUS } [ ALL | DISTINCT ] select ]\n"
					  "    [ ORDER BY {expression [ [ ASC | DESC | USING operator ] | nlssort_expression_clause ] [ NULLS { FIRST | LAST } ]} [, ...] ]\n"
					  "    [ LIMIT { count | ALL } ]\n"
					  "    [ OFFSET start [ ROW | ROWS ] ]\n"
					  "    [ FETCH { FIRST | NEXT } [ count ] { ROW | ROWS } ONLY ]\n"
					  "    [ {FOR { UPDATE | SHARE } [ OF table_name [, ...] ] [ NOWAIT ]} [...] ];");
}

void
sql_help_SET(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "SET [ LOCAL | SESSION ]\n"
					  "    { {config_parameter { { TO | = } { value | DEFAULT } | FROM CURRENT }}};\n"
					  "SET [ SESSION | LOCAL ] TIME ZONE { timezone | LOCAL | DEFAULT };\n"
					  "SET [ SESSION | LOCAL ] NAMES encoding_name;\n"
					  "SET [ SESSION | LOCAL ] \n"
					  "    {CURRENT_SCHEMA { TO | = } { schema | DEFAULT }\n"
					  "    | SCHEMA 'schema'};\n"
					  "SET [ SESSION | LOCAL ] XML OPTION { DOCUMENT | CONTENT };");
}

void
sql_help_SET_CONSTRAINTS(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "SET CONSTRAINTS { ALL | name [, ...] } { DEFERRED | IMMEDIATE };");
}

void
sql_help_SET_ROLE(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "SET [ SESSION | LOCAL ] ROLE role_name PASSWORD 'password';\n"
					  "RESET ROLE;");
}

void
sql_help_SET_SESSION_AUTHORIZATION(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "SET [ SESSION | LOCAL ] SESSION AUTHORIZATION role_name PASSWORD 'password';\n"
					  "{SET [ SESSION | LOCAL ] SESSION AUTHORIZATION DEFAULT\n"
					  "   | RESET SESSION AUTHORIZATION};");
}

void
sql_help_SET_TRANSACTION(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "{SET [ LOCAL ] TRANSACTION|SET SESSION CHARACTERISTICS AS TRANSACTION}\n"
					  "  { ISOLATION LEVEL { READ COMMITTED | READ UNCOMMITTED }\n"
					  "  | { READ WRITE | READ ONLY | SERIALIZABLE | REPEATABLE READ }\n"
					  "  } [, ...]\n"
					  "SET TRANSACTION SNAPSHOT snapshot_id;");
}

void
sql_help_SHOW(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "SHOW { configuration_parameter | CURRENT_SCHEMA | TIME ZONE | TRANSACTION ISOLATION LEVEL | SESSION AUTHORIZATION | ALL };");
}

void
sql_help_START_TRANSACTION(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "START TRANSACTION\n"
					  "   [ { ISOLATION LEVEL { READ COMMITTED | READ UNCOMMITTED }\n"
					  "   | { READ WRITE | READ ONLY | SERIALIZABLE | REPEATABLE READ }\n"
					  "   } [, ...] ];");
}

void
sql_help_TRUNCATE(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "TRUNCATE [ TABLE ] [ ONLY ] {table_name [ * ]} [, ... ]\n"
					  "    [ CONTINUE IDENTITY ] [ CASCADE | RESTRICT ];\n"
					  "ALTER TABLE [ IF EXISTS  ] { [ ONLY  ] table_name  | table_name *  | ONLY ( table_name )  } \n"
					  "    TRUNCATE PARTITION { partition_name  | FOR (  partition_value  [, ...] )  } ;");
}

void
sql_help_UPDATE(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "UPDATE [ ONLY ] table_name [ * ] [ [ AS ] alias ]\n"
					  "    SET {column_name = { expression | DEFAULT } |\n"
					  "          ( column_name [, ...] ) = {( { expression | DEFAULT } [, ...] ) |sub_query }\n"
					  "          }[, ...]\n"
					  "    [ FROM from_list] [ WHERE condition ]\n"
					  "    [ RETURNING {* | {output_expression [ [ AS ] output_name ]} [, ...] }];");
}

void
sql_help_VACUUM(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "VACUUM [ ( { FULL | FREEZE | VERBOSE | {ANALYZE | ANALYSE }} [,...] ) ]\n"
					  "    [ table_name [ (column_name [, ...] ) ] ] [ PARTITION ( partition_name ) ];\n"
					  "VACUUM [ FULL [ COMPACT ] ] [ FREEZE ] [ VERBOSE ] [ table_name ] [ PARTITION ( partition_name ) ];\n"
					  "VACUUM [ FULL ] [ FREEZE ] [ VERBOSE ] { ANALYZE | ANALYSE } [ VERBOSE ] \n"
					  "    [ table_name [ (column_name [, ...] ) ] ] [ PARTITION ( partition_name ) ];\n"
					  "VACUUM DELTAMERGE [ table_name ];\n"
					  "VACUUM HDFSDIRECTORY [ table_name ];");
}

void
sql_help_VALUES(PQExpBuffer buf)
{
	appendPQExpBuffer(buf,
					  "VALUES {( expression [, ...] )} [, ...]\n"
					  "    [ ORDER BY {sort_expression [ ASC | DESC | USING operator ]} [, ...] ]\n"
					  "    [ LIMIT { count | ALL } ]\n"
					  "    [ OFFSET start [ ROW | ROWS ] ]\n"
					  "    [ FETCH { FIRST | NEXT } [ count ] { ROW | ROWS } ONLY ];");
}

